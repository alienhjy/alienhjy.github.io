<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 黄家垚的主页</title>
    <link>http://blog.systemctl.top/tags/golang/</link>
    <description>Recent content in Golang on 黄家垚的主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2015 Copyleft Text</copyright>
    <lastBuildDate>Thu, 18 Feb 2016 15:10:37 +0800</lastBuildDate>
    <atom:link href="http://blog.systemctl.top/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[转载]filling a slice using command line flags in go</title>
      <link>http://blog.systemctl.top/2016/2016-02-18_filling-a-slice-using-command-line-flags-in-go/</link>
      <pubDate>Thu, 18 Feb 2016 15:10:37 +0800</pubDate>
      
      <guid>http://blog.systemctl.top/2016/2016-02-18_filling-a-slice-using-command-line-flags-in-go/</guid>
      <description>&lt;p&gt;I wanted to be able to specify a particular command-line flag more than once
in a Go program. I was about to throw my hands up in despair because I didn’t
think that the Go flag package could process multiple instances of a
command-line flag. I was wrong.&lt;/p&gt;

&lt;p&gt;While I was tempted to write my own command-line options parser,
I chose to find the idiomatic way to approach the problem.
If I have learned nothing else from my GoMentors,
I have learned to try to follow the idioms and to try not to reinvent the wheel.&lt;/p&gt;

&lt;p&gt;I found an example by visiting &lt;a href=&#34;http://golang.org/pkg/flag/&#34;&gt;http://golang.org/pkg/flag/&lt;/a&gt; .
I had to search for the string “FlagSet” in my browser.
Immediately under the paragraph where the word “FlagSet” first appears,
is a clickable item labeled “Example”.
Click the example item and take a look at the code.&lt;/p&gt;

&lt;p&gt;I copied the code and toyed with it until I thought I understood it.
Then, I tried to simplify it and rewrite it.
My example program will simply accept one or more command-line flags
with the label -i.  Each argument to -i should be an integer.
I want to be able to specify -i multiple times on the command-line.
The program should populate a slice of integers while adhering
to the above command-line syntax.&lt;/p&gt;

&lt;p&gt;Here’s my code … flagstuff.go :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2013 - by Jim Lawless
// License: MIT / X11
// See: http://www.mailsend-online.com/license2013.php
//
// Bear with me ... I&#39;m a Go noob.
 
package main
 
import (
    &amp;quot;flag&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
)
 
// Define a type named &amp;quot;intslice&amp;quot; as a slice of ints
type intslice []int
 
// Now, for our new type, implement the two methods of
// the flag.Value interface...
// The first method is String() string
func (i *intslice) String() string {
    return fmt.Sprintf(&amp;quot;%d&amp;quot;, *i)
}
 
// The second method is Set(value string) error
func (i *intslice) Set(value string) error {
    fmt.Printf(&amp;quot;%s\n&amp;quot;, value)
    tmp, err := strconv.Atoi(value)
    if err != nil {
        *i = append(*i, -1)
    } else {
        *i = append(*i, tmp)
    }
    return nil
}
 
var myints intslice
 
func main() {
    flag.Var(&amp;amp;myints, &amp;quot;i&amp;quot;, &amp;quot;List of integers&amp;quot;)
    flag.Parse()
    if flag.NFlag() == 0 {
        flag.PrintDefaults()
    } else {
        fmt.Println(&amp;quot;Here are the values in &#39;myints&#39;&amp;quot;)
        for i := 0; i &amp;lt; len(myints); i++ {
            fmt.Printf(&amp;quot;%d\n&amp;quot;, myints[i])
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s dissect the code one section at a time … not necessarily in the order
presented in the source code above.&lt;/p&gt;

&lt;p&gt;First, I define a type called intslice that refers to a slice of ints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type intslice []int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Later, I define a variable named myints of type intslice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var myints intslice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Later in the code, I’m going to be calling flag.Var() passing in &amp;amp;myints as
the first argument.  The type of the first value to flag.Var() must conform
to the flag.Value interface which is defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Value interface {
    String() string
    Set(string) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I must now define a String() method and a Set() method for my intslice type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (i *intslice) String() string {
    return fmt.Sprintf(&amp;quot;%d&amp;quot;, *i)
}
 
func (i *intslice) Set(value string) error {
    fmt.Printf(&amp;quot;%s\n&amp;quot;, value)
    tmp, err := strconv.Atoi(value)
    if err != nil {
        *i = append(*i, -1)
    } else {
        *i = append(*i, tmp)
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above methods will be called by the parsing engine in the flag package
when I invoke flag.Parse(). In the String() method, I need to return
a string-representation of the argument. In the Set() method,
I then need to append the string value to the specified intslice variable
by first converting value to an int variable named tmp. If an error occurs
during conversion, I append an int value of -1 to the intslice variable.&lt;/p&gt;

&lt;p&gt;The main body looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    flag.Var(&amp;amp;myints, &amp;quot;i&amp;quot;, &amp;quot;List of integers&amp;quot;)
    flag.Parse()
    if flag.NFlag() == 0 {
        flag.PrintDefaults()
    } else {
        fmt.Println(&amp;quot;Here are the values in &#39;myints&#39;&amp;quot;)
        for i := 0; i &amp;lt; len(myints); i++ {
            fmt.Printf(&amp;quot;%d\n&amp;quot;, myints[i])
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are a few sample command-line invocations and the output that they produce
( I’ve added a blank line between each command and the counterpart
response lines for clarity):&lt;/p&gt;

&lt;p&gt;No parameters. I’ve added a check to make sure that more than
zero flags are specified.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff
 
  -i=[]: List of integers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s specify an invalid flag (-x):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -x
 
flag provided but not defined: -x
Usage of flagstuff:
  -i=[]: List of integers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s specify -i without an argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i
 
Usage of flagstuff:
  -i=[]: List of integers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s specify a single -i parameter with an integer value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i 5
 
5
Here are the values in &#39;myints&#39;
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At each invocation of the intslice.Set() method, I display the string that
has been passed in so that I could observe the mechanics of the parsing process.
In each example that provide arguments for -i, we’ll first see those values,
then we’ll see what the slice contains via the for loop that occurs just
a little later in the code.&lt;/p&gt;

&lt;p&gt;Let’s specify a string instead of an int as an argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i twelve
 
twelve
Here are the values in &#39;myints&#39;
-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this causes the error condition in the call to strconv.Atoi().
I have chosen to add the value -1 to the slice when the argument
doesn’t cleanly parse as an integer.
You may choose to handle the error differently.&lt;/p&gt;

&lt;p&gt;Here is an example with three valid integers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i 5 -i 6 -i 7
 
5
6
7
Here are the values in &#39;myints&#39;
5
6
7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the example at golang.org contains a section that splits
the string value passed to Set() based on the presence of the comma character.
This allows that code to also accept multiple arguments to a single
command-line flag. I have chosen to avoid doing that to simplify my example.&lt;/p&gt;

&lt;p&gt;Knowing how to handle multiple occurrences of a given flag without customizing
the command-line parser is going to be very helpful for a couple of programs
that I plan to write. I’m glad that I spent the time going over
the example golang.org code. I hope to tinker with more exotic command-line
processing features of the flag package in the near future.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;https://lawlessguy.wordpress.com/2013/07/23/filling-a-slice-using-command-line-flags-in-go-golang/&#34;&gt;https://lawlessguy.wordpress.com/2013/07/23/filling-a-slice-using-command-line-flags-in-go-golang/&lt;/a&gt;
太长了懒得翻译了，又不是不能看。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang发送http请求</title>
      <link>http://blog.systemctl.top/2016/2016-01-12_golang-http-request/</link>
      <pubDate>Tue, 12 Jan 2016 18:05:00 +0800</pubDate>
      
      <guid>http://blog.systemctl.top/2016/2016-01-12_golang-http-request/</guid>
      <description>

&lt;p&gt;本篇记录一下golang中发送一个http请求的基本方法。&lt;br /&gt;
在本例中，我将尝试向某个URL发送GET请求，并获取其返回的body。&lt;/p&gt;

&lt;h5 id=&#34;b-开门见山的示例代码-b&#34;&gt;&lt;b&gt;开门见山的示例代码&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
)

func GetHttpBody(str_api string) ([]byte) {
	const (
		Http_username = &amp;quot;apiuser&amp;quot;
		Http_passwd = &amp;quot;apipasswd&amp;quot;
	)

	client := &amp;amp;http.Client{}
	req, err_req := http.NewRequest(&amp;quot;GET&amp;quot;, str_api, nil)
	if err_req != nil {
		fmt.Println(&amp;quot;Can&#39;t add http request.&amp;quot;, err_req)
		os.Exit(1)
	}
	req.Header.Add(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;)
	req.SetBasicAuth(Http_username, Http_passwd)

	resp, err_resp := client.Do(req)
	if err_req != nil {
		fmt.Println(&amp;quot;Can&#39;t get http response.&amp;quot;, err_resp)
		os.Exit(1)
	}
	resp_body, _ := ioutil.ReadAll(resp.Body)
	defer resp.Body.Close()
	return resp_body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;b-为了防止自己不懂-尝试解释一下-b&#34;&gt;&lt;b&gt;为了防止自己不懂，尝试解释一下&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;该实例是将go作为http客户端来用，而不是作为server。&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client := &amp;amp;http.Client{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先需要创建一个http client。其实我也不知道为什么是这么创建的。创建http客户端的时候，
还可以控制它的重定向策略等等行为以及其它客户端设置。由于我自己对http协议基本不怎么了解，
所以就不去深究它还能加哪些控制方法了。&lt;br /&gt;
接着便是新建一个&lt;code&gt;http.Request&lt;/code&gt;。其中&lt;code&gt;http.Request.Header.Add&lt;/code&gt;给这个请求添加一条
http头。&lt;code&gt;http.Request.SetBasicAuth&lt;/code&gt;方法用来做基于http协议的、明文密码的基本身份认证。
&lt;code&gt;http.Request&lt;/code&gt;的第一个参数为http请求的方法，第二个参数为请求的URL，如果是&lt;code&gt;POST&lt;/code&gt;等
方法，则可以在第三个参数加上要POST的内容。第三个参数的类型为&lt;code&gt;io.Reader&lt;/code&gt;。
&lt;code&gt;client.DO&lt;/code&gt;将上面创建好的请求发送出去，并返回一个&lt;code&gt;http.Response&lt;/code&gt;，于是我们就可以通过
&lt;code&gt;http.Response.Body&lt;/code&gt;获取到服务器返回的http body。&lt;br /&gt;
&lt;code&gt;http.Response.Body&lt;/code&gt;作为一个&lt;code&gt;io.Reader&lt;/code&gt;，记得在读取完成后&lt;code&gt;Close&lt;/code&gt;掉。&lt;/p&gt;

&lt;p&gt;皆大欢喜皆大欢喜。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang中对slice切片进行append时的内存拷贝</title>
      <link>http://blog.systemctl.top/2015/2015-09-25_copy-action-while-append-to-slice-in-golang/</link>
      <pubDate>Fri, 25 Sep 2015 11:13:06 +0800</pubDate>
      
      <guid>http://blog.systemctl.top/2015/2015-09-25_copy-action-while-append-to-slice-in-golang/</guid>
      <description>

&lt;p&gt;Golang中有一个神奇的类型：slice。&lt;br /&gt;
之所以说它神奇，是因为它是有容量的，因此对于熟悉C语言的用户而言，
很难在C语言中找到一个跟slice对应的数据结构。&lt;br /&gt;
本文不对slice的众多特性进行说明，只谈论跟其append操作相关的内容。&lt;/p&gt;

&lt;h5 id=&#34;b-slice的长度与容量-b&#34;&gt;&lt;b&gt;Slice的长度与容量&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;数组切片 slice 本质上还是基于数组实现的，大概可以抽象为：一个指向原生数组的指针；
数组切片中的元素个数；数组切片已分配的存储空间。&lt;br /&gt;
既然是基于数组，数组本身是不可变长度的，而要实现可变长度，就需要对其存储空间
进行管理。那 go 是怎么对 slice 的存储空间进行管理的呢？&lt;br /&gt;
这时就需要注意到 slice 的中文名称了，数组切片。也就是说，go 本质上将数组弄成一个个
切片，当目前所包含的切片容量不足以容纳所需的元素的时候，就开辟一块新的切片。&lt;br /&gt;
因此，除了长度（length，用&lt;code&gt;len()&lt;/code&gt;函数获取）之外，slice 还包含了另一个属性：容量
（capacity，用&lt;code&gt;cap()&lt;/code&gt;函数获取）。Slice 的长度表示该 slice 中已经存放了多少个元素，
而容量则表示该 slice 已经分配了足以存放多少元素的空间。&lt;br /&gt;
我们可以用一下方法创建一个长度为 4、可容量为 8、用于存放 int 类型元素的 slice：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var sliceA []int = make([]int, 4, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们不指定 make() 的第三个参数 cap 时，切片容量默认等于初始长度，如以下方法可
创建一个长度和容量都为 8 的 slice：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var sliceB []int = make([]int, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;b-使用-append-方法添加元素-b&#34;&gt;&lt;b&gt;使用 append() 方法添加元素&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;前面说过 slice 是可变长度的，我们可以利用 append() 函数来为 slice 增加元素。&lt;br /&gt;
&lt;em&gt;前面也说过，本文只讨论 append() 方法，不讨论取子切片、copy() 等其它操作。&lt;/em&gt;&lt;br /&gt;
那么，作为以数组为基础的数据结构，它是怎么做到动态扩展长度的呢？其实就是通过创建
并合并新的切片。&lt;br /&gt;
为了方便讨论，我们姑且把初始化时数组切片的容量称为它的单位容量。&lt;b&gt;请注意这一说法是
无论在 Google 官方文档还是国内翻译文档都未见使用，仅是为了方便讨论而创造的。&lt;/b&gt;&lt;br /&gt;
当进行 append() 操作时，若当前容量足以容纳所有元素，则 append() 会直接把需要添加的
元素直接拷贝到当前已分配的空间内，已有的数据还都在原处，皆大欢喜。而且因为空间是预先
分配好的，不涉及多余的内存申请操作，因此能兼顾动态扩展的灵活性和预分配空间的效率。&lt;br /&gt;
然而，如果当前空间不足的话，又会怎么样呢？&lt;br /&gt;
如果遇到这种情况，append() 会尝试先给这个 slice 分配一个大小为一个单位容量的数组，
如果还不够，继续分配。&lt;/p&gt;

&lt;p&gt;这个时候&lt;b&gt;坑来了，坑来了，坑来了&lt;/b&gt;，重要的事情据说要说三遍。。。&lt;br /&gt;
append() 在为 slice 增加容量的时候，会创建新的 slice，然后把&lt;b&gt;已有的数据拷贝过去，
拷贝过去，拷贝了过去&lt;/b&gt;，因为我掉到过这个坑，所以还是要说三遍。。。&lt;br /&gt;
也就是说，不管你对已存在的数据有没有进行修改，它都要拷贝一遍。如果你认为这个拷贝操作
仅仅是多消耗了一些性能的话，那我们看看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

type StructClass struct {
	id int
}

func (this *StructClass) SetID(newid int) {
	this.id = newid
}

func (this *StructClass) PrintID() {
	go func() {
		for {
			// 每秒输出一次 id 值。
			time.Sleep(time.Second * 1)
			fmt.Println(this.id)
		}
	} ()
}

func main() {
	var (
		i int = 0
		pool []StructClass = make([]StructClass, 0, 4)
	)
	pool = append(pool, StructClass{})
	// 这里将 pool[0] 的 id 设置成 1 了。
	pool[0].SetID(1)
	// 启动一个 goroutine，反复输出 pool[0] 的 id。
	pool[0].PrintID()

	time.Sleep(time.Second * 5)
	for i = 0; i &amp;lt;=5; i = i + 1 {
		pool = append(pool, StructClass{})
	}
	// 请注意此时 pool[0] 的 id 被设置成了 2。
	pool[0].SetID(2)
	time.Sleep(time.Second * 5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先来分析一下程序应该怎么运行。&lt;br /&gt;
首先创建了一个容量为 4，长度为 0 的 slice，该 slice 的每个元素都是一个封装了
一个 goroutine 的结构体。至于怎么制造这么一个结构体，
请参考&lt;a href=&#34;http://blog.systemctl.top/2015/2015-09-20_using-class-like-cpp-in-golang/&#34;&gt;《在golang中使用C++风格的类》&lt;/a&gt;一文。
这时，我们为 pool 添加了一个元素，并为这个元素的成员&lt;code&gt;id&lt;/code&gt;赋予初值，然后让它下属
的 PrintID 方法每隔一秒打印一次它的&lt;code&gt;id&lt;/code&gt;值。&lt;br /&gt;
紧接着，我们为 pool 添加了六个元素，不过暂时不对它们进行操作。添加这六个元素的目的仅仅
是为了迫使 append() 方法为 pool 添加一块区域。&lt;br /&gt;
大约五秒钟后，我们将 pool[0] 的&lt;code&gt;id&lt;/code&gt;设置为2，并等待其输出五秒后退出。&lt;/p&gt;

&lt;p&gt;按道理来说，&lt;code&gt;pool[0].SetID(2)&lt;/code&gt;之后，程序应该是反复输出数字2，然而运行的结果是，程序
全程只输出数字1。&lt;br /&gt;
&lt;b&gt;原因是&lt;/b&gt;，当 slice 元素个数超过四个时，append() 会分配一块大小为 8 的空间，
然后把所有元素拷贝进去。虽然 slice 本身是一个指向数组的指针，但它包含的元素都是
实实在在的数据。在这个例子中，拷贝数据时，append() 实实在在地把 pool[0] 的 id 以及各函数的
定义都拷贝过去了，但正在运行的 goroutine 并不属于数据，因此本例中的那个正在运行
的 goroutine 还傻傻地去原来的地方读取 id 值（注意，此处读取 id 用的是指向结构体的指针，
该指针还是指向原来的数据）。&lt;/p&gt;

&lt;h5 id=&#34;b-代码修正-b&#34;&gt;&lt;b&gt;代码修正&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;既然我们知道了引发问题的原因，那事情也就好解决了。&lt;br /&gt;
我们只需在创建 slice 的时候，往里面存放指向 StructClass 的指针，而不是直接
存放 StructClass 结构体就行了。
上述代码其它部分保持不变，将&lt;code&gt;main&lt;/code&gt;函数修改为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	var (
		i int = 0
		pool []*StructClass = make([]*StructClass, 0, 4)	// 改了这行
	)
	pool = append(pool, new(StructClass))	// 还有这行
	// 这里将 pool[0] 的 id 设置成 1 了。
	pool[0].SetID(1)
	// 启动一个 goroutine，反复输出 pool[0] 的 id。
	pool[0].PrintID()

	time.Sleep(time.Second * 5)
	for i = 0; i &amp;lt;=5; i = i + 1 {
		pool = append(pool, new(StructClass))	// 还有这行
	}
	// 请注意此时 pool[0] 的 id 被设置成了 2。
	pool[0].SetID(2)
	time.Sleep(time.Second * 5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我懒，所以上述代码的运行结果我都懒得贴了。感兴趣的可以自己测试一下，修改后
的代码正如我们期望的那样，先输出1，五秒后输出2。&lt;br /&gt;
若 slice 存放的是指针，那在 append() 进行拷贝操作的时候，只是将指针的指向的地址拷贝过去，
&lt;code&gt;pool[0].SetID(2)&lt;/code&gt;语句修改的 id 和&lt;code&gt;pool[0].PrintID()&lt;/code&gt;取的 id 引用的地址始终是不变的。&lt;/p&gt;

&lt;h4 id=&#34;所以说-谁说带垃圾回收的语言不用考虑指针t-t&#34;&gt;所以说，谁说带垃圾回收的语言不用考虑指针T_T&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>在golang中使用C&#43;&#43;风格的类</title>
      <link>http://blog.systemctl.top/2015/2015-09-20_using-class-like-cpp-in-golang/</link>
      <pubDate>Sun, 20 Sep 2015 21:05:59 +0800</pubDate>
      
      <guid>http://blog.systemctl.top/2015/2015-09-20_using-class-like-cpp-in-golang/</guid>
      <description>

&lt;p&gt;对于接触过C++且刚入门golang的用户而言，有一点可能会让他们抓狂，
就是golang这货居然只有结构体（struct），没有类（class）！！！&lt;br /&gt;
其实不用担心，我们大可以用struct实现类似于class的功能。。。&lt;/p&gt;

&lt;h5 id=&#34;b-目的-b&#34;&gt;&lt;b&gt;目的：&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;使struct不仅仅能存储成员变量，还能拥有其成员函数。并且控制外部函数对私有成员变量的访问。
当然本文仅仅是为了实现上述目的而已，并不关心什么多态、继承等等一大堆乱七八糟的特性（好吧，其实是本渣并不懂那些高级特性）。&lt;/p&gt;

&lt;h5 id=&#34;b-c-中类的使用-b&#34;&gt;&lt;b&gt;C++中类的使用：&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;我们先来看一段C++中是怎么样使用类的。&lt;br /&gt;
首先我们来创建一个头文件&lt;code&gt;classa.h&lt;/code&gt;，如你所见，类名叫classa：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class classa {
private:
	int id;

public:
	void SetID(int);
	int GetID();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们再创建一个源文件&lt;code&gt;classa.cpp&lt;/code&gt;，用来实现classa的&lt;code&gt;SetID&lt;/code&gt;和&lt;code&gt;GetID&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;classa.h&amp;quot;

void classa::SetID(int newid) {
	this-&amp;gt;id = newid;
}

int classa::GetID() {
	return this-&amp;gt;id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，建立&lt;code&gt;main.cpp&lt;/code&gt;用来初始化一个类的实例，并尝试调用类中的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;classa.h&amp;quot;

using namespace std;

int main(int argc, char* argv[]) {
	classa ca;
	ca.SetID(4);
	cout &amp;lt;&amp;lt; ca.GetID() &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;g++ -o main main.cpp classa.cpp&lt;/code&gt;编译上述文件，并运行&lt;code&gt;./main&lt;/code&gt;，
如果输出了一个数字4，那这个classa类就应当是以正确的姿势被调用了。&lt;/p&gt;

&lt;h5 id=&#34;b-golang中为struct添加成员函数-b&#34;&gt;&lt;b&gt;golang中为struct添加成员函数&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;不多废话了，作为对比，我们把上述C++代码翻译成golang代码。&lt;br /&gt;
假定我们目前的工作目录为&lt;code&gt;GOPATH&lt;/code&gt;，我们在当前路径的子目录下创建一个
名叫&lt;code&gt;packagea&lt;/code&gt;的包，包文件在&lt;code&gt;GOPATH&lt;/code&gt;下的路径为&lt;code&gt;src/packagea/packagea.go&lt;/code&gt;，
内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package packagea

type StructClass struct {
	id int 
}

func (this *StructClass) SetID(newid int) {
	this.id = newid
}

func (this *StructClass) GetID() int {
	return this.id
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，编写&lt;code&gt;main&lt;/code&gt;包以使用&lt;code&gt;packagea&lt;/code&gt;包，&lt;code&gt;main&lt;/code&gt;包的位置应该在哪就不用多说了吧。&lt;br /&gt;
&lt;code&gt;main&lt;/code&gt;包的内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;packagea&amp;quot;
)

func main() {
	var (
		sc packagea.StructClass = packagea.StructClass{}
	)
	sc.SetID(4)
	fmt.Println(sc.GetID())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;为了便于新手（其实是我自己）理解，我尽量不会使用&lt;code&gt;:=&lt;/code&gt;来声明一个变量，
而是使用臭长臭长的显式声明，以容易对变量的类型一目了然。&lt;/em&gt;&lt;br /&gt;
如果你希望以指向结构体的指针的形式来声明&lt;code&gt;sc&lt;/code&gt;这个结构体，只需把
&lt;code&gt;sc packagea.StructClass = packagea.StructClass{}&lt;/code&gt;替换为
&lt;code&gt;sc *packagea.StructClass = &amp;amp;packagea.StructClass{}&lt;/code&gt;即可。&lt;/p&gt;

&lt;h5 id=&#34;b-总结-b&#34;&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;之前网上找的教程基本上都是把结构体和跟它们关联的函数放在&lt;code&gt;main.go&lt;/code&gt;（与方法调用者
在同一个包里）。
如果我们希望把它们模块化，当然需要把一个模块的东西放到单独的包中。这个时候需要
注意的是，小写字母开头的变量和方法都只能在同一个包中被使用，类似于C++类
中的&lt;code&gt;protect&lt;/code&gt;属性。至于&lt;code&gt;private&lt;/code&gt;属性？你把每个结构体以及它们关联的方法单独放到
一个包不久行了。。。&lt;br /&gt;
本文所说的这种用法其实应该是go里面很常见的用法，只是本人愚笨，搞了好久才搞清楚。
所以在这里记录一下，以便以后哪天又忘了的话可以翻阅。。。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>