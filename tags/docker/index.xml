<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on 黄家垚的主页</title>
    <link>http://blog.systemctl.top/tags/docker/</link>
    <description>Recent content in Docker on 黄家垚的主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2015 Copyleft Text</copyright>
    <lastBuildDate>Wed, 15 Jun 2016 14:27:14 +0800</lastBuildDate>
    <atom:link href="http://blog.systemctl.top/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[转载]深入Docker存储驱动</title>
      <link>http://blog.systemctl.top/2016/2016-06-15_docker-storage-drivers/</link>
      <pubDate>Wed, 15 Jun 2016 14:27:14 +0800</pubDate>
      
      <guid>http://blog.systemctl.top/2016/2016-06-15_docker-storage-drivers/</guid>
      <description>

&lt;p&gt;本文主要介绍了Docker所使用到的几种存储驱动。&lt;/p&gt;

&lt;hr /&gt;

&lt;style type=&#34;text/css&#34;&gt;
  .red-i { color: #fa0000; }
  .gray-i { color: #ccc; }
  .small { font-size: 70%; }
  .underline { text-decoration: underline; }
  .sidenote {
    float: right;
    width: 300px;
    padding: 5px;
    background-color: #eee;
    border: solid 1px gray;
    clear: right;
  }
  li p { line-height: 1.25em; }
&lt;/style&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;深入&#34;&gt;深入&lt;/h4&gt;

&lt;h4 id=&#34;docker-存储驱动&#34;&gt;Docker 存储驱动&lt;/h4&gt;

&lt;h5 id=&#34;toc_2&#34;&gt;*&lt;/h5&gt;

&lt;h5 id=&#34;jérôme-petazzoni-jpetazzo&#34;&gt;Jérôme Petazzoni - @jpetazzo&lt;/h5&gt;

&lt;h5 id=&#34;docker-docker&#34;&gt;Docker - @docker&lt;/h5&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;我是谁&#34;&gt;我是谁&lt;/h4&gt;

&lt;p class=&#34;sidenote&#34;&gt;&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt; 在的个人名片上至少标记着其中一项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/jpetazzo&#34;&gt;@jpetazzo&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tamer of Unicorns and Tinkerer Extraordinaire&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;脾气暴躁的法国DevOps人员 喜爱Shell scripts
&lt;br/&gt; &lt;span class=&#34;small&#34;&gt;Go Away Or I Will Replace You Wiz Le Very Small Shell Script&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有一些容器技术的使用经验
&lt;br/&gt; (负责 dotCloud PaaS 的构建和运维工作)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打算使用Markdown来制作ppt(这的确是个好主意)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;大纲&#34;&gt;大纲&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Docker速览&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;简要介绍 copy-on-write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Docker 存储驱动的发展历史&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;AUFS, BTRFS, Device Mapper, Overlay&lt;span class=&#34;gray-i&#34;&gt;fs&lt;/span&gt;, VFS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结论&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;docker速览&#34;&gt;Docker速览&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;docker是什么&#34;&gt;Docker是什么?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个由 &lt;em&gt;Docker Engine&lt;/em&gt; 和 &lt;em&gt;Docker Hub&lt;/em&gt; 组成的平台&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;*Docker Engine*指的是容器的运行时环境&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Docker是开源的 由Go语言所开发
&lt;br/&gt; &lt;span class=&#34;small&#34;&gt; &lt;a href=&#34;http://www.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go&#34;&gt;http://www.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它是一个守护进程, 被REST API控制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;还是不清楚，它到底是什么!?
&lt;br/&gt; 这周五 参与在线的 &amp;ldquo;Docker 101&amp;rdquo; 会议:
&lt;br/&gt; &lt;span class=&#34;small&#34;&gt; &lt;a href=&#34;http://www.meetup.com/Docker-Online-Meetup/events/219867087/&#34;&gt;http://www.meetup.com/Docker-Online-Meetup/events/219867087/&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;如果你在实际工作中从未使用过docker-以下内容可能会帮到你&#34;&gt;如果你在实际工作中从未使用过Docker 以下内容可能会帮到你 &amp;hellip;&lt;/h4&gt;

&lt;p&gt;This will help!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jpetazzo@tarrasque:~$ docker run -ti python bash
root@75d4bf28c8a5:/# pip install IPython
Downloading/unpacking IPython
  Downloading ipython-2.3.1-py3-none-any.whl (2.8MB): 2.8MB downloaded
Installing collected packages: IPython
Successfully installed IPython
Cleaning up...
root@75d4bf28c8a5:/# ipython
Python 3.4.2 (default, Jan 22 2015, 07:33:45) 
Type &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.

IPython 2.3.1 -- An enhanced Interactive Python.
?         -&amp;gt; Introduction and overview of IPython&#39;s features.
%quickref -&amp;gt; Quick reference.
help      -&amp;gt; Python&#39;s own help system.
object?   -&amp;gt; Details about &#39;object&#39;, use &#39;object??&#39; for extra details.

In [1]:
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;这个过程中-发生了什么&#34;&gt;这个过程中 发生了什么?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们创建了一个 容器 (~相当于一个轻量级的虚拟机),
&lt;br/&gt; 它拥有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文件系统 (基于一个 &lt;code&gt;python&lt;/code&gt; 镜像)&lt;/li&gt;
&lt;li&gt;网络栈（network stack）&lt;/li&gt;
&lt;li&gt;进程空间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们通过一个 &lt;code&gt;bash&lt;/code&gt; 进程来启动
&lt;br/&gt; (no &lt;code&gt;init&lt;/code&gt;, no &lt;code&gt;systemd&lt;/code&gt;, no problem)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们通过pip安装了IPython, 并且将它运行起来&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;在这个过程中哪些-span-class-underline-没有-span-发生&#34;&gt;在这个过程中哪些&lt;span class=&#34;underline&#34;&gt;没有&lt;/span&gt;发生 ?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;我们并没有完全地拷贝 &lt;code&gt;python&lt;/code&gt; 镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装过程在 容器 中完成, 而并非是在 镜像 中完成:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们并没有修改 &lt;code&gt;python&lt;/code&gt; 镜像本身&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们并没有影响其他容器的运行
&lt;br/&gt; (当前使用的镜像或者其他的镜像)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;为什么这个问题很重要&#34;&gt;为什么这个问题很重要?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们使用的是 &lt;em&gt;copy-on-write&lt;/em&gt; 机制
&lt;br/&gt; (Docker 帮助我们进行处理)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我们并没有对&amp;rsquo;python&amp;rsquo;镜像进行完整地拷贝，我们仅仅是跟踪容器相对于镜像所发生的变化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这个过程节省了大量的硬盘空间 (1 个容器 = 小于 1 MB 的存储空间)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节省了大量的时间 (1 个容器 = 小于 0.1s 的启动时间)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;对于-copy-on-write-的简要介绍&#34;&gt;对于 copy-on-write 的简要介绍&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;历史背景&#34;&gt;历史背景&lt;/h4&gt;

&lt;p&gt;注意: 我并非是一个历史学家.&lt;/p&gt;

&lt;p&gt;下面这些零散信息介绍的并不全面.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;copy-on-write-ram&#34;&gt;Copy-on-write  (RAM)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt; (linux中的进程创建函数)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;快速地创建一个新的进程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip; 即使是这个进程使用了许多 GBs 的 RAM&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在类似于 e.g. Redis &lt;code&gt;SAVE&lt;/code&gt;的功能中被频繁地使用,
&lt;br/&gt; 为了获得一致的镜像（consistent snapshots）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;mmap()&lt;/code&gt; (将文件映射到指定内存空间) 使用 &lt;code&gt;MAP_PRIVATE&lt;/code&gt;参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用MAP_PRIVATE参数之后 内存段变为私有 改变仅对本进程可见Changes are visible only to current process&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;私有映射进行得很快 即使对大文件也是这样Private maps are fast, even on huge files&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;粒度: 1 次一个页面 (通常大小为 4 KB)&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;copy-on-write-在内存服务中的应用-ram&#34;&gt;Copy-on-write 在内存服务中的应用 (RAM)&lt;/h4&gt;

&lt;p class=&#34;sidenote&#34;&gt;
&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt; 位置 = 地址 = 指针
&lt;br/&gt;
&lt;span class=&#34;red-i&#34;&gt;²&lt;/span&gt; 操作 = 读、写或执行
&lt;/p&gt;

&lt;p&gt;它是如何工作的?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多亏了 MMU! (Memory Management Unit)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每次对内存的访问都需要通过MMU&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MMU可以把对于内存的访问请求 (虚拟的位置&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt; + 操作&lt;span class=&#34;red-i&#34;&gt;²&lt;/span&gt;) 转化为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实际的物理地址&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;或者会返回一个页错误 (&lt;em&gt;page fault&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;页错误-page-faults&#34;&gt;页错误（Page faults）&lt;/h4&gt;

&lt;p&gt;当页错误发生的时候,  MMU 就会通知 OS.&lt;/p&gt;

&lt;p&gt;之后会发生什么?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;要求访问不存在的内存空间 Access to non-existent memory area = &lt;code&gt;SIGSEGV&lt;/code&gt;
&lt;br/&gt;&lt;span class=&#34;small&#34;&gt;(即 &amp;ldquo;段错误 Segmentation fault&amp;rdquo; 或是 &amp;ldquo;请继续学习指针的使用&amp;rdquo;)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;访问已换出的内存空间 = 从硬盘中导入
&lt;br/&gt;&lt;span class=&#34;small&#34;&gt;(即 &amp;ldquo;我的程序怎么比以前满了1000倍&amp;rdquo;)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尝试向代码区写入内容 = seg fault (有时会发生)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尝试向拷贝区(copy area)写入内容 = 去重操作(deduplication operation)
&lt;br/&gt;&lt;span class=&#34;small&#34;&gt;之后如果什么也没有发生就恢复到初始化操作(initial operation)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在非执行区域也可以捕获尝试执行的请求
&lt;br/&gt;&lt;span class=&#34;small&#34;&gt;(比如利用栈来避免某些漏洞(stack, to protect against some exploits))&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;copy-on-write-在存储服务中的应用-disk&#34;&gt;Copy-on-write 在存储服务中的应用 (disk)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;最初的应用(个人看法)可能是 镜像服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(即是为更新频繁地数据库建立一致的备份 确保在开始备份到备份结束没有发生其他的操作)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在外接地存储设备上也可以使用(个人看法)Initially available  on external storage (NAS, SAN)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(因为这个部分确实很复杂)&lt;/p&gt;

&lt;p&gt;&amp;ndash;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;突然,
&lt;br/&gt;疯狂的 云计算 出现了!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;简要地介绍一下虚拟机-span-class-red-i-¹-span&#34;&gt;简要地介绍一下虚拟机&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt;&lt;/h4&gt;

&lt;p class=&#34;sidenote&#34;&gt;&lt;span class=&#34;small&#34;&gt;&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt; 不仅仅是虚拟机，还包括使用netboot的物理机 以及容器 也使用了类似地技术！&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于Copy-on-write存储服务构建系统镜像Put system image on copy-on-write storage&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为每一台虚拟机创建一个copy-on-write实例&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果系统镜像中包含了许多有用地软件 使用虚拟机的时候就不需要再安装额外的东西了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每一个额外生成地虚拟机仅仅需要硬盘空间来存储数据就行！&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;可以用在笔记本电脑上的现代copy-on-write技术&#34;&gt;可以用在笔记本电脑上的现代copy-on-write技术&lt;/h4&gt;

&lt;p&gt;(下面地排列并没有按照特定的顺序;列出的内容也并非详尽)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LVM (Logical Volume Manager) on Linux&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ZFS on Solaris, then FreeBSD, Linux &amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BTRFS on Linux&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;AUFS, UnionMount, overlay&lt;span class=&#34;gray-i&#34;&gt;fs&lt;/span&gt; &amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Virtual disks in VM hypervisors&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;copy-on-write-和-docker-的结合-一个美丽的爱情故事&#34;&gt;Copy-on-write 和 Docker 的结合: 一个美丽的爱情故事&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果没有 copy-on-write&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个容器永远无法启动起来&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;容器会占据很大的存储空间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你的笔记本电脑上没有&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在你的Linux主机上 Docker将不再有用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;我们应该感谢下面这些人&#34;&gt;我们应该感谢下面这些人:&lt;/h4&gt;

&lt;p&gt;Junjiro R. Okajima (以及其他的AUFS贡献者)&lt;/p&gt;

&lt;p&gt;Chris Mason (以及其他的BTRFS贡献者)&lt;/p&gt;

&lt;p&gt;Jeff Bonwick, Matt Ahrens (以及其他的ZFS贡献者)&lt;/p&gt;

&lt;p&gt;Miklos Szeredi (以及其他的overlay文件系统的贡献者)&lt;/p&gt;

&lt;p&gt;Linux device mapper, thinp target, 等等服务的众多贡献者&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;small&#34;&gt;&amp;hellip; 以及该领域的先驱者们 站在他们的肩上 我们才能看得更远 &lt;/span&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;docker-存储驱动-storage-drivers-的历史&#34;&gt;Docker 存储驱动(storage drivers)的历史&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;最初源于-aufs&#34;&gt;最初源于 AUFS&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Docker公司的前身是dotCloud
&lt;br/&gt;(PaaS层产品, 类似 Heroku, Cloud Foundry, OpenShift&amp;hellip;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dotCloud 从2008年开始使用AUFS技术
&lt;br/&gt;(那时 vserver, then OpenVZ 都开始使用AUFS, 之后是LXC)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于高密度的PaaS 应用 这是一个不错的选择
&lt;br/&gt;(后面我们会有具体介绍!)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;aufs-并不完美&#34;&gt;AUFS 并不完美&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并没有被包括在Linux的主线内核中&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用补丁程序曾经是一件激动人心地事情&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip; 特别是与 GRSEC 相结合&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip; 并且加上其他定制的功能比如 &lt;code&gt;setns()&lt;/code&gt;(将线程与namespace技术再结合)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;一些使用者一直信任aufs&#34;&gt;一些使用者一直信任AUFS!&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特别是dotCloud&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Debian 以及 Ubuntu 在他们默认地内核中 使用了AUFS
&lt;br/&gt;对于Live CD 以及类似的使用情况:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你的根文件系统有 copy-on-write 的功能 并且介于以下两层之间：
&lt;br/&gt;- 只读媒介 (CD, DVD&amp;hellip;)
&lt;br/&gt;- 可读写媒介 (disk, USB stick&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Docker 的第一个版本就是针对Ubuntu设计的 (以及 Debian)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;之后-一些人开始信赖-docker&#34;&gt;之后 一些人开始信赖 Docker&lt;/h4&gt;

&lt;p class=&#34;sidenote&#34;&gt;注意:其他的贡献者在这个过程中也提供了很多支持!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Red Hat用户要求在他们最受欢迎的发行版中添加对Docker的支持&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Red Hat Inc. 也想让这一切发生&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip; 他们于是为Docker贡献代码 添加了对 Device Mapper driver的支持&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip; 之后是 BTRFS driver&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip; 接着是 overlay&lt;span class=&#34;gray-i&#34;&gt;fs&lt;/span&gt; driver&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;特别感谢&#34;&gt;特别感谢:&lt;/h4&gt;

&lt;p&gt;Alexander Larsson&lt;/p&gt;

&lt;p&gt;Vincent Batts&lt;/p&gt;

&lt;p&gt;+ 当然还有全部地贡献者和维护者&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;small&#34;&gt;(上面两位贡献者在最初BTRFS、Device Mapper、以及overlay驱动的开发、支持和维护过程中扮演了极为重要的角色，再次感谢!)&lt;/span&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;让我们实际来看看&#34;&gt;让我们实际来看看&lt;/h4&gt;

&lt;h4 id=&#34;每一种存储驱动&#34;&gt;每一种存储驱动&lt;/h4&gt;

&lt;h4 id=&#34;是如何发挥作用的&#34;&gt;是如何发挥作用的&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;aufs&#34;&gt;AUFS&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;按照特定的顺序将多个分支结合在一起&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每一个分支都是一个标准的的目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通常会包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;至少一个只读分支 (在最低层)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;恰好一个读写分支 (再最顶层)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(也可能有其它的组合方式!)&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;当打开一个文件的时候-when-opening-a-file&#34;&gt;当打开一个文件的时候 When opening a file&amp;hellip;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;O_RDONLY&lt;/code&gt; - 只读的方式来进行访问:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在每一个分支中进行查找 ，从最顶层的分支开始&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开找到的第一个文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;O_WRONLY&lt;/code&gt; 或 &lt;code&gt;O_RDWR&lt;/code&gt; - 可写入的方式进行访问:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先在顶层分支中进行查找
&lt;br/&gt;如果在顶层分支中找到，就打开文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果没有找到, 就在其他分支中进行查找;
&lt;br/&gt;如果在其他分支中找到文件，就把它拷贝到读写分支中(顶层) 之后打开拷贝过去的文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果所打开的文件本身比较大 则向上拷贝的操作可能要多花一些时间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;当删除一个文件的时候&#34;&gt;当删除一个文件的时候&amp;hellip;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;此时会创建一个 &lt;em&gt;whiteout&lt;/em&gt; 文件
&lt;br/&gt;(这个与 &amp;ldquo;tombstones&amp;rdquo;的概念很类似)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#### docker run ubuntu rm /etc/shadow

#### ls -la /var/lib/docker/aufs/diff/$(docker ps --no-trunc -lq)/etc
total 8
drwxr-xr-x 2 root root 4096 Jan 27 15:36 .
drwxr-xr-x 5 root root 4096 Jan 27 15:36 ..
-r--r--r-- 2 root root    0 Jan 27 15:36 .wh.shadow
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;在实际操作中&#34;&gt;在实际操作中&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容器中AUFS的挂载点是
&lt;br/&gt;&lt;code&gt;/var/lib/docker/aufs/mnt/$CONTAINER_ID/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只有在容器运行地时候 文件系统才会被挂载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;AUFS的分支(只读分支和读写分支)的位置在
&lt;br/&gt;&lt;code&gt;/var/lib/docker/aufs/diff/$CONTAINER_OR_IMAGE_ID/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有写入的内容都存在 &lt;code&gt;/var/lib/docker&lt;/code&gt;目录下&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;dockerhost# df -h /var/lib/docker
Filesystem      Size  Used Avail Use% Mounted on
/dev/xvdb        15G  4.8G  9.5G  34% /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;高级选项-under-the-hood&#34;&gt;高级选项(Under the hood)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看 AUFS 挂载的相关细节:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;/proc/mounts&lt;/code&gt;文件夹下 查看 内部ID&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找&lt;code&gt;/sys/fs/aufs/si_.../br*&lt;/code&gt;目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以把每一个分支 (除去顶层的两个分支)
&lt;br/&gt;理解成一个镜像&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;实际例子-可以看到-除了最上面的两个分支之外-其他的分支都以镜像的形式体现出来&#34;&gt;实际例子(可以看到 除了最上面的两个分支之外 其他的分支都以镜像的形式体现出来)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;dockerhost# grep c7af /proc/mounts
none /mnt/.../c7af...a63d aufs rw,relatime,si=2344a8ac4c6c6e55 0 0

dockerhost# grep . /sys/fs/aufs/si_2344a8ac4c6c6e55/br[0-9]*
/sys/fs/aufs/si_2344a8ac4c6c6e55/br0:/mnt/c7af...a63d=rw
/sys/fs/aufs/si_2344a8ac4c6c6e55/br1:/mnt/c7af...a63d-init=ro+wh
/sys/fs/aufs/si_2344a8ac4c6c6e55/br2:/mnt/b39b...a462=ro+wh
/sys/fs/aufs/si_2344a8ac4c6c6e55/br3:/mnt/615c...520e=ro+wh
/sys/fs/aufs/si_2344a8ac4c6c6e55/br4:/mnt/8373...cea2=ro+wh
/sys/fs/aufs/si_2344a8ac4c6c6e55/br5:/mnt/53f8...076f=ro+wh
/sys/fs/aufs/si_2344a8ac4c6c6e55/br6:/mnt/5111...c158=ro+wh

dockerhost# docker inspect --format {{.Image}} c7af
b39b81afc8cae27d6fc7ea89584bad5e0ba792127597d02425eaee9f3aaaa462

dockerhost# docker history -q b39b 
b39b81afc8ca
615c102e2290
837339b91538
53f858aaaf03
511136ea3c5a
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;性能以及调优-performance-tuning&#34;&gt;性能以及调优(Performance, tuning)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AUFS &lt;code&gt;mount()&lt;/code&gt; 速度很快 因此创建容器的过程也很快&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对内存进行读/写操作的速度与原先区别不大&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是最初的 &lt;code&gt;open()&lt;/code&gt; 操作 在写大文件的时候 比较费时&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在以下方面仍有问题:日志文件(log files),数据库(databases) &amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;并没有许多需要可以调优的地方(Not much to tune)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用技巧: 当我们构建dotCloud的时候，我们最后把所有重要的数据都放在存储卷上 (putting all important data on &lt;em&gt;volumes&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当多次启动一个容器的时候，数据只被从硬盘中导入了一次，并且只需要在内存中缓存一次(cached only once in memory)
(but &lt;code&gt;dentries&lt;/code&gt; will be duplicated)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;device-mapper&#34;&gt;Device Mapper&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;序&#34;&gt;序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Device Mapper 是一个复杂的子系统; 它可以完成以下工作:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;磁盘阵列(RAID)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设备编码(encrypted devices)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;镜像 (即使用 copy-on-write 机制)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以及其它地一些零碎地功能&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Docker的环境下, &amp;ldquo;Device Mapper&amp;rdquo; 指的是
&lt;br/&gt;&amp;ldquo;the Device Mapper system + its thin provisioning 存储&amp;rdquo;
&lt;br/&gt;(有些时候标记为 &amp;ldquo;thinp&amp;rdquo;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;原理-1&#34;&gt;原理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Copy-on-write 机制发生在存储块级别
&lt;br/&gt;(而不是文件级别)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每一个容器额每个镜像都有它们自己的块设备&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在任何给定地时间，都可能对以下内容进行快照：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;已经存在的容器 (创建一个静态的镜像(frozen image))&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;已经存在的镜像 (从镜像中创建一个文件)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果块设备一直没有被写入:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;就认为对应的空间没有内容(it&amp;rsquo;s assumed to be all zeros)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不会在硬盘上被分配空间
&lt;br/&gt;(所谓的 &amp;ldquo;thin&amp;rdquo; provisioning)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;在实际操作中-1&#34;&gt;在实际操作中&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容器挂载点的目录是在
&lt;br/&gt;&lt;code&gt;/var/lib/docker/devicemapper/mnt/$CONTAINER_ID/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只有在容器运行的时候 才会被挂载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据存在两个文件中，一个是&amp;rdquo;data&amp;rdquo;文件 一个是&amp;rdquo;metadata&amp;rdquo; 文件
&lt;br/&gt;(这个稍后会进行具体介绍)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为我们实际的工作在block的层面上进行，所以对于镜像和容器之间的差别，我们并不全部可见&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;高级选项-under-the-hood-1&#34;&gt;高级选项(Under the hood)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;docker info&lt;/code&gt; 命令会告诉你当前资源池的状态
&lt;br/&gt;(已用空间/可用空间)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;dmsetup ls&lt;/code&gt;列出全部可用设备&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设备名称以&amp;rdquo;docker-MAJ:MIN-INO&amp;rdquo;为前缀&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span class=&#34;small&#34;&gt;MAJ, MIN, and INO 这几个简称来源于存储Docker数据的主块设备(block major) 从块设备(block minor) 以及索引结点号(inode number) (为了避免运行多个Docker实例的时候发生冲突 即在Docker中运行Docker)&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;dmsetup info&lt;/code&gt;, &lt;code&gt;dmsetup status&lt;/code&gt;命令可以查看更多的信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;镜像有一个内部的数值形式的ID&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;/var/lib/docker/devicemapper/metadata/$CONTAINER_OR_IMAGE_ID&lt;/code&gt;
&lt;br/&gt;是一个小的JSON文件 用于跟踪记录镜像的ID以及它的大小&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;!-- # Example --&gt;

&lt;h4 id=&#34;额外的细节&#34;&gt;额外的细节&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要两个存储区:
&lt;br/&gt;一个用于存储数据(data), 另一个用于存储元信息(metadata)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ldquo;data&amp;rdquo; 也可以理解成 &amp;ldquo;pool&amp;rdquo;; 它是一个存储块构成的巨大的资源池
&lt;br/&gt;(Docker使用尽可能小的存储块，64KB)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ldquo;元信息(metadata)&amp;ldquo;包含了虚拟地址偏移(在镜像中)到实际物理偏移 (在资源池中)的映射&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每一次一个新的存储块(或者一个copy-on-write块被写入)
一个存储块就从资源池中被分配出来&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当资源池中没有新地存储块时，尝试进行写入的操作就会停止，直到资源池中资源的数量增加(或者写操作被终止)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;性能performance&#34;&gt;性能Performance&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认情况下 Docker将数据和元信息都存储在一个由稀疏文件(sparse file)做支撑的loop device上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从可用性的角度来看 这一点比较方便
&lt;br/&gt;(基本上不需要进行配置)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从性能的角度来看 可能比较糟糕&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每一次 一个容器都向一个新的存储块中写入内&lt;/li&gt;
&lt;li&gt;存储块由资源池所分配&lt;/li&gt;
&lt;li&gt;并且在向存储块中写入内容时&lt;/li&gt;
&lt;li&gt;存储块必须从稀疏文件中分配而来&lt;/li&gt;
&lt;li&gt;而稀疏文件系统的性能并不怎么好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;优化tuning&#34;&gt;优化Tuning&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;帮自己一个忙：如果你想使用 Device Mapper
&lt;br/&gt;就把数据(以及元信息)存在实际的设备上(real devices)!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;终止Docker进程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改参数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除 &lt;code&gt;/var/lib/docker&lt;/code&gt; (这一点很重要!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启Docker进程&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;docker -d --storage-opt dm.datadev=/dev/sdb1 --storage-opt dm.metadatadev=/dev/sdc1
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;进一步优化more-tuning&#34;&gt;进一步优化More tuning&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;让每一个容器都有它自己的块存储设备&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;上面有一个真实的文件系统&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所以你也可以调整 (通过&lt;code&gt;--storage-opt&lt;/code&gt;参数):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件系统的类别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件系统的大小&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;discard&lt;/code&gt; (这个后面有更多介绍)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;警告: 当你1000次启动容器的时候,
&lt;br/&gt;文件会从硬盘中被导入1000次!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;可以参考以下资料&#34;&gt;可以参考以下资料&lt;/h4&gt;

&lt;p&gt;&lt;span class=&#34;small&#34;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt&#34;&gt;https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper&#34;&gt;https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Sparse_file&#34;&gt;http://en.wikipedia.org/wiki/Sparse_file&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Trim_%28computing%29&#34;&gt;http://en.wikipedia.org/wiki/Trim_%28computing%29&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;btrfs&#34;&gt;BTRFS&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;原理-2&#34;&gt;原理&lt;/h4&gt;

&lt;p class=&#34;sidenote&#34;&gt;&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt; 这个操作可以通过`btrfs` 工具来完成.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在文件系统的级别上完成全部的&amp;rdquo;copy-on-write&amp;rdquo;的工作&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt; 一个 &amp;ldquo;subvolume&amp;rdquo; (设想 &lt;code&gt;mkdir&lt;/code&gt; 操作有极大的权限)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对任何的 subvolume 在任何时候生成镜像&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;BTRFS 从文件系统的级别而非是存储块设备的级别 将镜像和资源管理池的特性结合在一起&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;在实际操作中-2&#34;&gt;在实际操作中&lt;/h4&gt;

&lt;p class=&#34;sidenote&#34;&gt;&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt; 即有连续地写入流的情况下.
&lt;br/&gt;性能可能是原先的性能(native performance)的一半&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;/var/lib/docker&lt;/code&gt;必须要是一个BTRFS文件系统&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于一个容器或者一个镜像 BTRFS 的挂载点位于
&lt;br/&gt;&lt;code&gt;/var/lib/docker/btrfs/subvolumes/$CONTAINER_OR_IMAGE_ID/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;即使容器没有在运行BTRFS也会被使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据并没有直接被写入而是先是被写入到日志(it goes to the journal first)
&lt;br/&gt;(在某些情况下&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt;, 这可能会影响性能)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;高级选项-under-the-hood-2&#34;&gt;高级选项(Under the hood)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;BTRFS 通过把存储设备分成不同的数据块(chunks)来发挥作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个数据块包含着元标签或者元信息(meta or metadata)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你可以用完全部的数据块 (会得到 &lt;code&gt;No space left on device&lt;/code&gt;的消息)
&lt;br/&gt;即便如此通过 &lt;code&gt;df&lt;/code&gt; 命令还是会显示出有可用空间
&lt;br/&gt;(因为存储块并没有占满所有空间(because the chunks are not full))&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;快速修复:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#### btrfs filesys balance start -dusage=1 /var/lib/docker
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;!-- # Example --&gt;

&lt;h4 id=&#34;性能以及调优&#34;&gt;性能以及调优&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;没有太多可以优化的地方&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意 &lt;code&gt;btrfs filesys show&lt;/code&gt; 命令的输出!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;表明文件系统正在正常运行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#### btrfs filesys show
Label: none  uuid: 80b37641-4f4a-4694-968b-39b85c67b934
        Total devices 1 FS bytes used 4.20GiB
        devid    1 size 15.25GiB used 6.04GiB path /dev/xvdc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这种情况是文件块全部占满的情况(没有空闲的文件块) 即使上面没有太多的数据信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#### btrfs filesys show
Label: none  uuid: de060d4c-99b6-4da0-90fa-fb47166db38b
        Total devices 1 FS bytes used 2.51GiB
        devid    1 size 87.50GiB used 87.50GiB path /dev/xvdc
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;overlay-span-class-gray-i-fs-span&#34;&gt;Overlay&lt;span class=&#34;gray-i&#34;&gt;fs&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;序-1&#34;&gt;序&lt;/h4&gt;

&lt;p&gt;为何将&lt;span class=&#34;gray-i&#34;&gt;fs&lt;/span&gt;标记为灰色?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它曾经被称为 &lt;code&gt;overlayfs&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当并入到 3.18 版本之后, 名称就变为了 &lt;code&gt;overlay&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;原理-3&#34;&gt;原理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这个文件系统与AUFS很类似，只有很少的地方有差别:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只有两个分支only two branches (被称为文件层(&amp;ldquo;layers&amp;rdquo;))&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是分支只能进行自我覆盖&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;在实际操作中-3&#34;&gt;在实际操作中&lt;/h4&gt;

&lt;p class=&#34;sidenote&#34;&gt;&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt;
对于其他发行版的适配工作就交给读者来完成
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;你需要内核版本为 3.18&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Ubuntu&lt;span class=&#34;red-i&#34;&gt;¹&lt;/span&gt;上:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;go to &lt;a href=&#34;http://kernel.ubuntu.com/~kernel-ppa/mainline/&#34;&gt;http://kernel.ubuntu.com/~kernel-ppa/mainline/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;locate the most recent directory, e.g. &lt;code&gt;v3.18.4-vidi&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;download the &lt;code&gt;linux-image-..._amd64.deb&lt;/code&gt; file&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;dpkg -i&lt;/code&gt; that file, reboot, enjoy&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;高级选项-under-the-hood-3&#34;&gt;高级选项(Under the hood)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;镜像以及容器在以下目录下被具体化
&lt;br/&gt;&lt;code&gt;/var/lib/docker/overlay/$ID_OF_CONTAINER_OR_IMAGE&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;镜像只有一个&amp;rsquo;root&amp;rsquo;子目录
&lt;br/&gt;(包含了root FS)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;容器含有:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;lower-id&lt;/code&gt; → 文件包含镜像的ID&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;merged/&lt;/code&gt; → 容器的挂载点(需要在运行的时候)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;upper/&lt;/code&gt; → 容器的读写层&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;work/&lt;/code&gt; → 用于原子拷贝操作的临时的空间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;!-- # Example --&gt;

&lt;h4 id=&#34;性能以及调优performance-tuning&#34;&gt;性能以及调优Performance, tuning&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;目前阶段没有什么需要调优的地方&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;性能方面应该与AUFS比较类似:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;向上拷贝速度较慢&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对内存资源的利用较好&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具体实现细节:
&lt;br/&gt;同样的文件在不同镜像之间通过硬链接的方式连在一起
&lt;br/&gt;(这样可以避免进行复杂的覆盖( avoids doing composed overlays))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;vfs&#34;&gt;VFS&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;原理-4&#34;&gt;原理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;没有 copy on write 机制 Docker每次都要进行全部的拷贝!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;并没有依赖于这些及为花哨的内核机&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当将Docker移植到一个新的平台上的时候 这是一个不错的选择
&lt;br/&gt;(think FreeBSD, Solaris&amp;hellip;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空间利用率低 速度慢&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;在实际操作中-4&#34;&gt;在实际操作中&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;在产品安装的时候可能比较有用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(如果你不想/不能 使用 存储卷，并且不想/不能使用任何 copy-on-write机制)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;结论&#34;&gt;结论&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;
关于Docker存储驱动，最棒的就是，用户可以有如此多的选择。
&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;哪种情况应该选择哪种文件系统-what-do-what-do&#34;&gt;哪种情况应该选择哪种文件系统？(What do, what do?)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果你做的是PaaS或使用其他的密集环境(high-density environment):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AUFS (要求内核提供对应的支持)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;overlayfs (在其他的情况下)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你把一个大的可写的文件放在CoW文件系统:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;BTRFS or Device Mapper (选择一个你最了解的)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;总而言之&#34;&gt;总而言之&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;
在你的产品上
&lt;br/&gt;最好的存储驱动
&lt;br/&gt;是你的团队有最多的实际操作经验的那一种
&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;特别内容-bonus-track&#34;&gt;特别内容(Bonus track)&lt;/h4&gt;

&lt;h5 id=&#34;discard-and-trim&#34;&gt;&lt;code&gt;discard&lt;/code&gt; and &lt;code&gt;TRIM&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;trim&#34;&gt;&lt;code&gt;TRIM&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发送给SSD硬盘的内容 告诉SSD硬盘Command sent to a SSD disk, to tell it:
&lt;br/&gt;&amp;ldquo;这个存储块已经不在被使用了&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这个功能很有用 因为对于SSD来说 *erase*的代价非常高 (速度很慢)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;允许SSD 来提前预先擦除cells
&lt;br/&gt;(并不是即时的 而是在 写操作之前)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这也对支持 copy-on-write 机制的存储有意义
&lt;br/&gt;(如果/当 所有的镜像都作为一个trimmed block 那么它就可以被释放)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;discard&#34;&gt;&lt;code&gt;discard&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件系统选择的含义:
&lt;br/&gt;&lt;em&gt;&amp;ldquo;can I has &lt;code&gt;TRIM&lt;/code&gt; on this pls&amp;rdquo;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Can be enabled/disabled at any time&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;文件系统也可以使用&lt;code&gt;fstrim&lt;/code&gt;通过手工地方式被修剪(be trimmed)
&lt;br/&gt;(即使对于已经挂载了的文件系统)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;discard-的困惑&#34;&gt;&lt;code&gt;discard&lt;/code&gt; 的困惑&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;discard&lt;/code&gt; 在 Device Mapper + loopback devices 上工作&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip; 但是在 loopback devices 上速度特别慢
&lt;br/&gt;(在容器或者镜像删除之后 loopback文件需要被&amp;rdquo;re-sparsified&amp;rdquo; 这是一个特别慢的操作)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;你可以根据自己的偏好将其打开或者关闭&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;h4 id=&#34;以上就是全部的内容&#34;&gt;以上就是全部的内容!&lt;/h4&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;questions&#34;&gt;Questions?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;To get those slides, follow me on twitter: &lt;a href=&#34;https://twitter.com/jpetazzo&#34;&gt;@jpetazzo&lt;/a&gt;
&lt;br/&gt;&lt;span class=&#34;small&#34;&gt;Yes, this is a particularly evil scheme to increase my follower count&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Also &lt;span class=&#34;red-i&#34;&gt;WE ARE HIRING!&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;infrastructure (servers, metal, and stuff)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;QA (get paid to break things!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python (Docker Hub and more)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Go (Docker Engine and more)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Send your resume to jobs@docker.com
&lt;br/&gt;&lt;span class=&#34;gray-i&#34;&gt;Do it do it do it NOW NOW!&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;http://static.dockerone.com/ppt/filedriver.html&#34;&gt;http://static.dockerone.com/ppt/filedriver.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;*注：原文是一个用Markdown写的PPT，非常有趣，建议可以看看。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在RHEL6.2上安装docker的准备工作</title>
      <link>http://blog.systemctl.top/2015/2015-11-06_prepare-for-install-docker-in-rhel_6.2/</link>
      <pubDate>Fri, 06 Nov 2015 19:01:12 +0800</pubDate>
      
      <guid>http://blog.systemctl.top/2015/2015-11-06_prepare-for-install-docker-in-rhel_6.2/</guid>
      <description>

&lt;p&gt;最近在尝试 docker，据说很高端大气上档次，于是就在空闲的时候开始鼓捣整。&lt;br /&gt;
壮哉我大 Arch，内核版本都已经是 4.x 了（截至写本文），完全满足 docker 对内核版本的要求
（推荐 3.16，最低 3.10，据说红帽的 2.6.32-358 以上由于被打了补丁，也能支持 docker）。&lt;/p&gt;

&lt;p&gt;然而事情总不会一帆风顺，比如某些线上环境，可能还在用很古老的发行版。&lt;br /&gt;
现在，我就很奇葩地想要在 RHEL 6.2 上安装 docker。然而 RHEL 6.2 默认使用的内核是
2.6.32-220，并不满足 docker 的要求，于是就需要稍微升级一下内核。
俗话说，步子跨得大了，容易扯到蛋。所以我们选择版本号变化不那么大的 RHEL 6.6 版本自带
的 2.6.32-504 内核。&lt;/p&gt;

&lt;h4 id=&#34;更新内核版本&#34;&gt;更新内核版本&lt;/h4&gt;

&lt;p&gt;首先系统的更新内核版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -ivh --force http://yum.pplive.com/rhel_6.6_repo/Packages/kernel-2.6.32-504.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/kernel-firmware-2.6.32-504.el6.noarch.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/bfa-firmware-3.2.23.0-2.el6.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于部分设备，可能会出现依赖不满足。比如我遇到&lt;code&gt;bfa-firmware&lt;/code&gt;包的依赖出现问题，这时，卸载掉旧版本的，
再尝试安装内核，即可解决。可以这样卸载（我不说你也懂）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum remove bfa-firmware
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;更新device-mapper包&#34;&gt;更新device-mapper包&lt;/h4&gt;

&lt;p&gt;更新内核后，如果你直接安装运行 docker，会发现启动不了 docker 的服务。不管你有没有这个问题，
反正我是遇到了。这时检查是哪个组件不符合要求，比如我的环境下，是 device-mapper 包版本太低，
更新一下即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -ivh --force http://yum.pplive.com/rhel_6.6_repo/Packages/device-mapper-libs-1.02.90-2.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/device-mapper-1.02.90-2.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/util-linux-ng-2.17.2-12.18.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/libblkid-2.17.2-12.18.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/libuuid-2.17.2-12.18.el6.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装docker&#34;&gt;安装docker&lt;/h4&gt;

&lt;p&gt;话说，标题我不是说了吗，这是准备工作。。。&lt;br /&gt;
接下来，就可以像 RHEL/CentOS 6.5 以上的系统一样，添加&lt;code&gt;epel&lt;/code&gt;源，然后直接安装&lt;code&gt;docker-io&lt;/code&gt;包了。&lt;br /&gt;
神马？怎么添加&lt;code&gt;epel&lt;/code&gt;？怎么安装&lt;code&gt;docker-io&lt;/code&gt;？bing/Google 一下一大堆，这都不会的话还是先回去
补基础吧，别急着用 docker 了。。。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>