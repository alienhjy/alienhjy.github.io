<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>黄家垚的主页</title>
    <link>http://alienhjy.github.io/</link>
    <description>Recent content on 黄家垚的主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2015 Copyleft Text</copyright>
    <lastBuildDate>Thu, 18 Feb 2016 15:10:37 +0800</lastBuildDate>
    <atom:link href="http://alienhjy.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[转载]filling a slice using command line flags in go</title>
      <link>http://alienhjy.github.io/2016/2016-02-18_filling-a-slice-using-command-line-flags-in-go/</link>
      <pubDate>Thu, 18 Feb 2016 15:10:37 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2016/2016-02-18_filling-a-slice-using-command-line-flags-in-go/</guid>
      <description>&lt;p&gt;I wanted to be able to specify a particular command-line flag more than once
in a Go program. I was about to throw my hands up in despair because I didn’t
think that the Go flag package could process multiple instances of a
command-line flag. I was wrong.&lt;/p&gt;

&lt;p&gt;While I was tempted to write my own command-line options parser,
I chose to find the idiomatic way to approach the problem.
If I have learned nothing else from my GoMentors,
I have learned to try to follow the idioms and to try not to reinvent the wheel.&lt;/p&gt;

&lt;p&gt;I found an example by visiting &lt;a href=&#34;http://golang.org/pkg/flag/&#34;&gt;http://golang.org/pkg/flag/&lt;/a&gt; .
I had to search for the string “FlagSet” in my browser.
Immediately under the paragraph where the word “FlagSet” first appears,
is a clickable item labeled “Example”.
Click the example item and take a look at the code.&lt;/p&gt;

&lt;p&gt;I copied the code and toyed with it until I thought I understood it.
Then, I tried to simplify it and rewrite it.
My example program will simply accept one or more command-line flags
with the label -i.  Each argument to -i should be an integer.
I want to be able to specify -i multiple times on the command-line.
The program should populate a slice of integers while adhering
to the above command-line syntax.&lt;/p&gt;

&lt;p&gt;Here’s my code … flagstuff.go :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2013 - by Jim Lawless
// License: MIT / X11
// See: http://www.mailsend-online.com/license2013.php
//
// Bear with me ... I&#39;m a Go noob.
 
package main
 
import (
    &amp;quot;flag&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
)
 
// Define a type named &amp;quot;intslice&amp;quot; as a slice of ints
type intslice []int
 
// Now, for our new type, implement the two methods of
// the flag.Value interface...
// The first method is String() string
func (i *intslice) String() string {
    return fmt.Sprintf(&amp;quot;%d&amp;quot;, *i)
}
 
// The second method is Set(value string) error
func (i *intslice) Set(value string) error {
    fmt.Printf(&amp;quot;%s\n&amp;quot;, value)
    tmp, err := strconv.Atoi(value)
    if err != nil {
        *i = append(*i, -1)
    } else {
        *i = append(*i, tmp)
    }
    return nil
}
 
var myints intslice
 
func main() {
    flag.Var(&amp;amp;myints, &amp;quot;i&amp;quot;, &amp;quot;List of integers&amp;quot;)
    flag.Parse()
    if flag.NFlag() == 0 {
        flag.PrintDefaults()
    } else {
        fmt.Println(&amp;quot;Here are the values in &#39;myints&#39;&amp;quot;)
        for i := 0; i &amp;lt; len(myints); i++ {
            fmt.Printf(&amp;quot;%d\n&amp;quot;, myints[i])
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s dissect the code one section at a time … not necessarily in the order
presented in the source code above.&lt;/p&gt;

&lt;p&gt;First, I define a type called intslice that refers to a slice of ints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type intslice []int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Later, I define a variable named myints of type intslice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var myints intslice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Later in the code, I’m going to be calling flag.Var() passing in &amp;amp;myints as
the first argument.  The type of the first value to flag.Var() must conform
to the flag.Value interface which is defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Value interface {
    String() string
    Set(string) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I must now define a String() method and a Set() method for my intslice type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (i *intslice) String() string {
    return fmt.Sprintf(&amp;quot;%d&amp;quot;, *i)
}
 
func (i *intslice) Set(value string) error {
    fmt.Printf(&amp;quot;%s\n&amp;quot;, value)
    tmp, err := strconv.Atoi(value)
    if err != nil {
        *i = append(*i, -1)
    } else {
        *i = append(*i, tmp)
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above methods will be called by the parsing engine in the flag package
when I invoke flag.Parse(). In the String() method, I need to return
a string-representation of the argument. In the Set() method,
I then need to append the string value to the specified intslice variable
by first converting value to an int variable named tmp. If an error occurs
during conversion, I append an int value of -1 to the intslice variable.&lt;/p&gt;

&lt;p&gt;The main body looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    flag.Var(&amp;amp;myints, &amp;quot;i&amp;quot;, &amp;quot;List of integers&amp;quot;)
    flag.Parse()
    if flag.NFlag() == 0 {
        flag.PrintDefaults()
    } else {
        fmt.Println(&amp;quot;Here are the values in &#39;myints&#39;&amp;quot;)
        for i := 0; i &amp;lt; len(myints); i++ {
            fmt.Printf(&amp;quot;%d\n&amp;quot;, myints[i])
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are a few sample command-line invocations and the output that they produce
( I’ve added a blank line between each command and the counterpart
response lines for clarity):&lt;/p&gt;

&lt;p&gt;No parameters. I’ve added a check to make sure that more than
zero flags are specified.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff
 
  -i=[]: List of integers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s specify an invalid flag (-x):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -x
 
flag provided but not defined: -x
Usage of flagstuff:
  -i=[]: List of integers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s specify -i without an argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i
 
Usage of flagstuff:
  -i=[]: List of integers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let’s specify a single -i parameter with an integer value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i 5
 
5
Here are the values in &#39;myints&#39;
5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At each invocation of the intslice.Set() method, I display the string that
has been passed in so that I could observe the mechanics of the parsing process.
In each example that provide arguments for -i, we’ll first see those values,
then we’ll see what the slice contains via the for loop that occurs just
a little later in the code.&lt;/p&gt;

&lt;p&gt;Let’s specify a string instead of an int as an argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i twelve
 
twelve
Here are the values in &#39;myints&#39;
-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this causes the error condition in the call to strconv.Atoi().
I have chosen to add the value -1 to the slice when the argument
doesn’t cleanly parse as an integer.
You may choose to handle the error differently.&lt;/p&gt;

&lt;p&gt;Here is an example with three valid integers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flagstuff -i 5 -i 6 -i 7
 
5
6
7
Here are the values in &#39;myints&#39;
5
6
7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the example at golang.org contains a section that splits
the string value passed to Set() based on the presence of the comma character.
This allows that code to also accept multiple arguments to a single
command-line flag. I have chosen to avoid doing that to simplify my example.&lt;/p&gt;

&lt;p&gt;Knowing how to handle multiple occurrences of a given flag without customizing
the command-line parser is going to be very helpful for a couple of programs
that I plan to write. I’m glad that I spent the time going over
the example golang.org code. I hope to tinker with more exotic command-line
processing features of the flag package in the near future.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;https://lawlessguy.wordpress.com/2013/07/23/filling-a-slice-using-command-line-flags-in-go-golang/&#34;&gt;https://lawlessguy.wordpress.com/2013/07/23/filling-a-slice-using-command-line-flags-in-go-golang/&lt;/a&gt;
太长了懒得翻译了，又不是不能看。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[转载]awk &amp; sed ，一个老派系统管理员的基本素养</title>
      <link>http://alienhjy.github.io/2016/2016-02-01_remember-sed-awk-linux-admins-should/</link>
      <pubDate>Mon, 01 Feb 2016 15:01:13 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2016/2016-02-01_remember-sed-awk-linux-admins-should/</guid>
      <description>&lt;p&gt;&lt;font color=red&gt;我们不要让下一代 Linux 和 Unix 的管理员忘记初始化脚本和基本工具的好处&lt;/font&gt;&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;http://alienhjy.github.io/images/remember-sed-awk-linux-admins-should/01.jpg&#34;/&gt;&lt;/br&gt;
图片来源: Shutterstock
&lt;/div&gt;

&lt;p&gt;我曾经有一次在 Reddit 看到一个帖子，
“&lt;a href=&#34;https://www.reddit.com/r/linuxadmin/comments/3lwyko/how_do_i_remove_every_occurence_of_duplicate_line/&#34;&gt;请问如何操作文本文件&lt;/a&gt;”。
这是一个很简单的需求，就像我们常用 Unix 的人每天遇到的一样。他的问题是，
如何删除文件中的重复行，只保留不重复的。 这听起来似乎很简单，但是当文件足够大时，就会有些复杂。&lt;/p&gt;

&lt;p&gt;这个问题有很多种不同的答案。你可以使用几乎任何一种语言来写这样的一个脚本，
只是时间的投入和代码的复杂性不同罢了。根据你的个人水平，它大概会花费20-60分钟。
但是如果你使用了 Perl、Python、Ruby 中的一种，你可能很快实现它。&lt;/p&gt;

&lt;p&gt;或者你可以使用下面的一个方法，让你无比暖心的: 只用 awk。&lt;/p&gt;

&lt;p&gt;这个答案是迄今为止最简明、最简单的解决问题的方法。它只要一行！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk &#39;!seen[$0]++&#39; &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们来看看发生了什么：&lt;/p&gt;

&lt;p&gt;在这个命令中，其实隐藏了很多代码。awk 是一种文本处理语言，并且它内部有很多预设。
首先，你看到的实际上是一个 for 循环的结果。awk 假定你想通过循环处理输入文件的每一行，
所以你不需要明确的去指定它。awk 还假定了你需要打印输出处理后的数据，所以你也不需要去指定它。
最后，awk 假定循环在最后一句指令执行完结束，这一块也不再需要你去指定它。&lt;/p&gt;

&lt;p&gt;这个例子中的字符串 seen 是一个关联数组的名字。$0 是一个变量，表示整个当前行。所以，
这个命令翻译成人类语言就是“对这个文件的每一行进行检查，如果你之前没有见过它，就打印出来。
”如果该关联数组的键名还不存在就添加到数组，并增加其取值，这样 awk 下次遇到同样的行时就会不匹配
（条件判断为“假”），从而不打印出来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;据微博上 &lt;a href=&#34;http://weibo.com/3246109510&#34;&gt;@ZorroLang&lt;/a&gt; 的补充：少提了一个重点，
要不然只会 C 语言的人很难理解为什么 seen[$0]++ 一行代码就行了，
这里隐含了 awk 对于其数组变量的处理方式。awk 的数组是关联数组，且不需要声明，
而是引用即创建，注意是创建，后面都不会消失的。也就是你像 str[any] 这样随便写一个数组变量，
这个数组元素就此就创建了，且初始化为0或空。&lt;/p&gt;

&lt;p&gt;谢谢 &lt;a href=&#34;http://weibo.com/3246109510&#34;&gt;@ZorroLang&lt;/a&gt; ~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一些人认为这样是优雅的，另外的人认为这可能会造成混淆。任何在日常工作上使用 awk
的都是第一类人。awk 就是设计用来做这个的。在 awk 中，你可以写多行代码。
你甚至可以&lt;a href=&#34;http://intro-to-awk.blogspot.com/2008/08/awk-more-complex-examples.html&#34;&gt;用 awk 写一些让人不安的复杂功能&lt;/a&gt;。
但终究来说，awk 还是一个进行文本处理的程序，一般是通过管道。
去掉（没必要的）循环定义是很常见的快捷用法，不过如果你乐意，你也可以用下面的代码做同样的事情：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk &#39;{ if (!seen[$0]) print $0; seen[$0]++ }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会产生相同的结果。&lt;/p&gt;

&lt;p&gt;awk 是完成这项工作的完美工具。不过，我相信很多管理员&amp;ndash;特别是新管理员会转而使用
&lt;a href=&#34;http://www.infoworld.com/article/2613338/linux/linux-how-to-script-a-bash-crash-course.html&#34;&gt;Bash&lt;/a&gt;
或 Python 来完成这一任务，因为对 awk 的知识和对它的能力的了解看起来随着时间而慢慢被人淡忘。
我认为这是标志着一个问题，由于对之前的解决方案缺乏了解，那些已经解决了几十年的问题又突然出现了。&lt;/p&gt;

&lt;p&gt;shell、grep、sed 和 awk 是 Unix 的基础。如果你不能非常轻松的使用它们，你将会被自己束缚住，
因为它们构成了通过命令行和脚本与 Unix 系统交互的基础。
学习这些工具如何工作最好的方法之一就是观察真实的例子和实验，
你可以在各种 Unix 衍生系统的初始化系统中找到很多，但在 Linux 发行版中它们已经被
&lt;a href=&#34;http://www.infoworld.com/article/2608798/data-center/systemd--harbinger-of-the-linux-apocalypse.html&#34;&gt;systemd&lt;/a&gt; 取代了。&lt;/p&gt;

&lt;p&gt;数以百万计的 Unix 管理员了解 Shell 脚本和 Unix 工具如何读、写、修改和用在初始化脚本上。
不同系统的初始化脚本有很大不同，甚至是不同的 Linux 发行版也不同。但是它们都源自 sh，
而且它们都用像 sed、awk 还有 grep 这样的核心的命令行工具。&lt;/p&gt;

&lt;p&gt;我每天都会听到很多人抱怨初始化脚本太“古老”而且很“难”。但是实际上，
初始化脚本和 Unix 管理员每天使用的工具一样，还提供了一个非常好的方式来更加熟悉和习惯这些工具。
说初始化脚本难于阅读和难于使用实际上是承认你缺乏对 Unix 基础工具的熟悉。&lt;/p&gt;

&lt;p&gt;说起在 Reddit 上看到的内容，我也碰到过这个问题，来自一个新入行的 Linux 系统管理员,
“&lt;a href=&#34;https://www.reddit.com/r/linuxadmin/comments/3ltq2y/when_i_start_learning_about_linux_administration/&#34;&gt;问他是否应该还要去学老式的初始化系统 sysvinit&lt;/a&gt;”。
这个帖子的大多数的答案都是正面的——是的，应该学习 sysvinit 和 systemd 两个。
一位评论者甚至指出，初始化脚本是学习 Bash 的好方法。而另一个消息是，
Fortune 50 强的公司还没有计划迁移到以 systemd 为基础的发行版上。&lt;/p&gt;

&lt;p&gt;但是，这提醒了我这确实是一个问题。如果我们继续沿着消除脚本和脱离操作系统核心组件的方式发展下去，
由于疏于接触，我们将会不经意间使新管理员难于学习基本的 Unix 工具。&lt;/p&gt;

&lt;p&gt;我不知道为什么有些人想在一层又一层的抽象化来掩盖 Unix 内部，
但是这样发展下去可能会让新一代的系统管理员们变成只会按下按钮的工人。我觉得这不是一件好事情。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;http://www.infoworld.com/article/2985804/linux/remember-sed-awk-linux-admins-should.html&#34;&gt;http://www.infoworld.com/article/2985804/linux/remember-sed-awk-linux-admins-should.html&lt;/a&gt;&lt;br /&gt;
译文原文地址：&lt;a href=&#34;https://linux.cn/article-6881-1.html&#34;&gt;https://linux.cn/article-6881-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：&lt;a href=&#34;http://www.infoworld.com/author/Paul-Venezia/&#34;&gt;Paul Venezia&lt;/a&gt;
译者：&lt;a href=&#34;https://github.com/Bestony&#34;&gt;Bestony&lt;/a&gt;
校对：&lt;a href=&#34;https://github.com/wxy&#34;&gt;wxy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文由 &lt;a href=&#34;https://github.com/LCTT/TranslateProject&#34;&gt;LCTT&lt;/a&gt; 原创编译，
&lt;a href=&#34;https://linux.cn/article-6881-1.html&#34;&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[转载]最简明扼要的 Systemd 教程，只需十分钟</title>
      <link>http://alienhjy.github.io/2016/2016-01-20_linux-101-get-the-most-out-of-systemd/</link>
      <pubDate>Wed, 20 Jan 2016 17:05:29 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2016/2016-01-20_linux-101-get-the-most-out-of-systemd/</guid>
      <description>

&lt;p&gt;systemd 是 Linux 下的一款系统和服务管理器，兼容 SysV 和 LSB 的启动脚本。
systemd 的特性有：支持并行化任务；同时采用 socket 式与 D-Bus 总线式激活服务；
按需启动守护进程（daemon）；利用 Linux 的 cgroups 监视进程；支持快照和系统恢复；
维护挂载点和自动挂载点；各服务间基于依赖关系进行精密控制。&lt;/p&gt;

&lt;h5 id=&#34;前言:0d6c59cee5b31ce37e9176fed3a35e29&#34;&gt;前言&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;干嘛要这么做？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;理解现代 Linux 发行版中的显著变化；&lt;br /&gt;
看看 Systemd 是如何取代 SysVinit 的；&lt;br /&gt;
搞定单元（unit）和新的 journal 日志。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;吐槽邮件、人身攻击、死亡威胁——Lennart Poettering，Systemd 的作者，
对收到这些东西早就习以为常了。这位 Red Hat 公司的员工之前在 Google+ 上怒斥 FOSS
社区(&lt;a href=&#34;http://tinyurl.com/poorlennart&#34;&gt;http://tinyurl.com/poorlennart&lt;/a&gt;)的本质，悲痛且失望地表示：“那真是个令人恶心的地方”。
他着重指出 Linus Torvalds 在邮件列表上言辞极其刻薄的帖子，
并谴责这位内核的领导者为在线讨论定下基调，并使得人身攻击及贬抑之辞成为常态。&lt;/p&gt;

&lt;p&gt;但为何 Poettering 会遭受如此多的憎恨？为何就这么个搞搞开源软件的人要忍受这等愤怒？
答案就在于他的软件的重要性。如今大多数发行版中，Systemd 是 Linux 内核发起的第一个程序，
并且它还扮演多种角色。它会启动系统服务、处理用户登录，每隔特定的时间执行一些任务，还有很多很多。
它在不断地成长，并逐渐成为 Linux 的某种“基础系统”——提供系统启动和发行版维护所需的所有工具。&lt;/p&gt;

&lt;p&gt;如今，在以下几点上 Systemd 颇具争议：它逃避了一些已经确立的 Unix 传统，例如纯文本的日志文件；
它被看成是个“大一统”的项目，试图接管一切；它还是我们这个操作系统的支柱的重要革新。
然而大多数主流发行版已经接受了（或即将接受）它，因此它就活了下来。而且它确实是有好处的：
更快地启动，更简单地管理那些有依赖的服务程序，提供强大且安全的日志系统等。&lt;/p&gt;

&lt;p&gt;因此在这篇教程中，我们将探索 Systemd 的特性，并向您展示如何最有效地利用这些特性。
即便您此刻并不是这款软件的粉丝，读完本文后您至少可以更加了解和适应它。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;http://alienhjy.github.io/images/linux-101-get-the-most-out-of-systemd/01.gif&#34;&gt;&lt;/br&gt;
这部没正经的动画片来自http://tinyurl.com/m2e7mv8，它把 Systemd 塑造成一只狂暴的动物，吞噬它路过的一切。大多数批评者的言辞可不像这只公仔一样柔软。
&lt;/div&gt;

&lt;h5 id=&#34;启动及服务:0d6c59cee5b31ce37e9176fed3a35e29&#34;&gt;启动及服务&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;大多数主流发行版要么已经采用 Systemd，要么即将在下个发布中采用（如 Debian 和
Ubuntu）。在本教程中，我们使用 Fedora 21（该发行版已经是 Systemd
的优秀实验场地）的一个预览版进行演示，但不论您用哪个发行版，
要用到的命令和注意事项都应该是一样的。这是 Systemd 的一个加分点：
它消除了不同发行版之间许多细微且琐碎的区别。&lt;/p&gt;

&lt;p&gt;在终端中输入&lt;code&gt;ps ax | grep systemd&lt;/code&gt;，看到第一行，其中的数字&lt;strong&gt;1&lt;/strong&gt;表示它的进程号是1，
也就是说它是 Linux 内核发起的第一个程序。因此，内核一旦检测完硬件并组织好了内存，
就会运行&lt;code&gt;/usr/lib/systemd/systemd&lt;/code&gt;可执行程序，这个程序会按顺序依次发起其他程序。
（在还没有 Systemd 的日子里，内核会去运行&lt;code&gt;/sbin/init&lt;/code&gt;，
随后这个程序会在名为 SysVinit 的系统中运行其余的各种启动脚本。）&lt;/p&gt;

&lt;p&gt;Systemd 的核心是一个叫单元(unit)的概念，它是一些存有关于服务（service，
在运行在后台的程序）、设备、挂载点、和操作系统其他方面信息的配置文件。
Systemd 的其中一个目标就是简化这些事物之间的相互作用，
因此如果你有程序需要在某个挂载点被创建或某个设备被接入后开始运行，
Systemd 可以让这一切正常运作起来变得相当容易。（在没有 Systemd 的日子里，
要使用脚本来把这些事情调配好，那可是相当丑陋的。）要列出您 Linux 系统上的所有单元，
输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl list-unit-files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，&lt;code&gt;systemctl&lt;/code&gt;是与 Systemd 交互的主要工具，它有不少选项。在单元列表中，
您会注意到这儿有一些格式化：被启用(enabled)的单元显示为绿色，被禁用(disabled)的显示为红色。
标记为“static”的单元不能直接启用，它们是其他单元所依赖的对象。若要限制输出列表只包含服务，
使用以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl list-unit-files --type=service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;转载者注：disabled 指的是这个单元不会在开机的时候自动执行，并不影响使用&lt;code&gt;systemctl&lt;/code&gt;
方式来启动它。同理。enabled 指的是这个单元在开机的时候会被自动执行。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;注意，一个单元显示为“enabled”，并不等于对应的服务正在运行，而只能说明它可以被开启。
要获得某个特定服务的信息，以 GDM (Gnome Display Manager) 为例，输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl status gdm.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条命令提供了许多有用的信息：一段给人看的服务描述、单元配置文件的位置、启动的时间、
进程号，以及它所从属的 CGroups（用以限制各组进程的资源开销）。&lt;/p&gt;

&lt;p&gt;如果您去查看位于&lt;code&gt;/usr/lib/systemd/system/gdm.service&lt;/code&gt;的单元配置文件，
您可以看到各种选项，包括要被运行的二进制文件（“ExecStart”那一行），
相冲突的其他单元（即不能同时进入运行的单元），以及需要在本单元执行前进入运行的单元
（“After”那一行）。一些单元有附加的依赖选项，例如“Requires”（必要的依赖）和“Wants”
（可选的依赖）。&lt;/p&gt;

&lt;p&gt;此处另一个有趣的选项是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Alias=display-manager.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当您启动&lt;strong&gt;gdm.service&lt;/strong&gt;后，您将可以通过&lt;code&gt;systemctl status display-manager.service&lt;/code&gt;
来查看它的状态。当您知道有显示管理程序(display manager)在运行并想对它做点什么，
但您不关心那究竟是 GDM，KDM，XDM 还是什么别的显示管理程序时，这个选项会非常有用。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;http://alienhjy.github.io/images/linux-101-get-the-most-out-of-systemd/02.jpg&#34; /&gt;&lt;br&gt;
使用 systemctl status 命令后面跟一个单元名，来查看对应的服务有什么情况。
&lt;/div&gt;

&lt;h5 id=&#34;目标-target-锁定:0d6c59cee5b31ce37e9176fed3a35e29&#34;&gt;“目标”(target) 锁定&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;如果您在&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;目录中输入&lt;code&gt;ls&lt;/code&gt;命令，您将看到各种以&lt;code&gt;.target&lt;/code&gt;结尾的文件。
启动目标(target)是一种将多个单元聚合在一起以致于将它们同时启动的方式。例如，对大多数类 Unix
操作系统而言有一种“多用户”(multi-user)状态，意思是系统已被成功启动，后台服务正在运行，
并且已准备好让一个或多个用户登录并工作——至少在文本模式下。
（其他状态包括用于进行管理工作的单用户(single-user)状态，
以及用于机器关机的重启状态。）&lt;/p&gt;

&lt;p&gt;如果您打开&lt;strong&gt;multi-user.target&lt;/strong&gt;文件一探究竟，您可能期待看到的是一个要被启动的单元列表。
但您会发现这个文件内部几乎空空如也——其实，一个服务会通过&lt;strong&gt;WantedBy&lt;/strong&gt;
选项让自己成为启动目标的依赖。因此如果您去打开&lt;strong&gt;avahi-daemon.service&lt;/strong&gt;,
&lt;strong&gt;NetworkManager.service&lt;/strong&gt;及其他&lt;strong&gt;.service&lt;/strong&gt;文件看看，
您将在 Install 段看到这一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，切换到多用户启动目标会启用(enable)那些包含上述语句的单元。
还有其他一些启动目标可用（例如&lt;strong&gt;emergency.target&lt;/strong&gt;提供一个紧急情况使用的 shell，
以及&lt;strong&gt;halt.target&lt;/strong&gt;用于机器关机），您可以用以下方式轻松地在它们之间切换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl isolate emergency.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在许多方面，这些都很像 SysVinit 中的运行级(runlevel)，如文本模式的
&lt;strong&gt;multi-user.target&lt;/strong&gt;类似于第3运行级，&lt;strong&gt;graphical.target&lt;/strong&gt;类似于第5运行级，
&lt;strong&gt;reboot.target&lt;/strong&gt;类似于第6运行级，诸如此类。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;http://alienhjy.github.io/images/linux-101-get-the-most-out-of-systemd/03.jpg&#34; /&gt;&lt;br/&gt;
与传统的脚本相比，单元配置文件也许看起来很陌生，但并不难以理解。
&lt;/div&gt;

&lt;h5 id=&#34;开启与停止:0d6c59cee5b31ce37e9176fed3a35e29&#34;&gt;开启与停止&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;现在您也许陷入了沉思：我们已经看了这么多，但仍没看到如何停止和开启服务！
这其实是有原因的。从外部看，Systemd 也许很复杂，像野兽一般难以驾驭。因此在您开始摆弄它之前，
有必要从宏观的角度看看它是如何工作的。实际用来管理服务的命令非常简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl stop cups.service
systemctl start cups.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（若某个单元被禁用了，您可以先通过&lt;code&gt;systemctl enable&lt;/code&gt;加上该单元名的方式将其启用。
这种做法会为该单元创建一个符号链接，并将其放置在当前启动目标的&lt;code&gt;.wants&lt;/code&gt;目录下，这些&lt;code&gt;.wants&lt;/code&gt;
目录在&lt;code&gt;/etc/systemd/system&lt;/code&gt;文件夹中。）&lt;/p&gt;

&lt;p&gt;还有两个有用的命令是&lt;code&gt;systemctl restart&lt;/code&gt;和&lt;code&gt;systemctl reload&lt;/code&gt;，后面接单元名。
后者用于让单元重新加载它的配置文件。Systemd 的绝大部分都有良好的文档，
因此您可以查看手册 (&lt;code&gt;man systemctl&lt;/code&gt;) 了解每条命令的细节。&lt;/p&gt;

&lt;h5 id=&#34;定时器单元-取代-cron:0d6c59cee5b31ce37e9176fed3a35e29&#34;&gt;定时器单元：取代 Cron&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;除了系统初始化和服务管理，Systemd 还染指了其他方面。在很大程度上，它能够完成&lt;strong&gt;cron&lt;/strong&gt;的工作，
而且可以说是以更灵活的方式（并带有更易读的语法）。&lt;strong&gt;cron&lt;/strong&gt;
是一个以规定时间间隔执行任务的程序——例如清除临时文件，刷新缓存等。&lt;/p&gt;

&lt;p&gt;如果您再次进入&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;目录，您会看到那儿有多个&lt;code&gt;.timer&lt;/code&gt;文件。
用&lt;code&gt;less&lt;/code&gt;来查看这些文件，您会发现它们与&lt;code&gt;.service&lt;/code&gt;和&lt;code&gt;.target&lt;/code&gt;文件有着相似的结构，
而区别在于&lt;code&gt;[Timer]&lt;/code&gt;段。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Timer]
OnBootSec=1h
OnUnitActiveSec=1w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OnBootSec&lt;/strong&gt;选项告诉 Systemd 在系统启动一小时后启动这个单元。
第二个选项的意思是：自那以后每周启动这个单元一次。关于定时器有大量选项您可以设置，
输入&lt;code&gt;man systemd.time&lt;/code&gt;查看完整列表。&lt;/p&gt;

&lt;p&gt;Systemd 的时间精度默认为一分钟。也就是说，它会在设定时刻的一分钟内运行单元，
但不一定精确到那一秒。这么做是基于电源管理方面的原因，
但如果您需要一个没有任何延时且精确到毫秒的定时器，您可以添加以下一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;AccuracySec=1us
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，&lt;strong&gt;WakeSystem&lt;/strong&gt;选项（可以被设置为 true 或 false）决定了定时器是否可以唤醒处于休眠状态的机器。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;http://alienhjy.github.io/images/linux-101-get-the-most-out-of-systemd/04.jpg&#34;/&gt;&lt;/br&gt;
有一个 Systemd 的图形界面程序，即便它已有多年未被积极维护。
&lt;/div&gt;

&lt;h5 id=&#34;日志文件-向-journald-问声好:0d6c59cee5b31ce37e9176fed3a35e29&#34;&gt;日志文件：向 journald 问声好&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;Systemd 的第二个主要部分是 journal 。这是个日志系统，类似于&lt;code&gt;syslog&lt;/code&gt;但也有些显著区别。
如果您是个 Unix 日志管理模式的粉丝，准备好出离愤怒吧：这是个二进制日志，
因此您不能使用常规的命令行文本处理工具来解析它。这个设计决定不出意料地在网上引起了激烈的争论，
但它的确有些优点。例如，日志可以被更系统地组织，带有更多的元数据，
因此可以更容易地根据可执行文件名和进程号等过滤出信息。&lt;/p&gt;

&lt;p&gt;要查看整个 journal，输入以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;journalctl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像许多其他的 Systemd 命令一样，该命令将输出通过管道的方式引向&lt;code&gt;less&lt;/code&gt;程序，
因此您可以使用空格键向下滚动，键入&lt;code&gt;/&lt;/code&gt;（斜杠）查找，以及其他熟悉的快捷键。
您也能在此看到少许颜色，像红色的警告及错误信息。&lt;/p&gt;

&lt;p&gt;以上命令会输出很多信息。为了限制其只输出本次启动的消息，使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;journalctl -b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是 Systemd 大放异彩的地方！您想查看自上次启动以来的全部消息吗？
试试&lt;code&gt;journalctl -b -1&lt;/code&gt;吧。再上一次的？用&lt;code&gt;-2&lt;/code&gt;替换&lt;code&gt;-1&lt;/code&gt;吧。那自某个具体时间，
例如2014年10月24日16:38以来的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;journalctl -b --since=”2014-10-24 16:38”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即便您对二进制日志感到遗憾，那依然是个有用的特性，并且对许多系统管理员来说，
构建类似的过滤器比起写正则表达式而言容易多了。&lt;/p&gt;

&lt;p&gt;我们已经可以根据特定的时间来准确查找日志了，那可以根据特定程序吗？对单元而言，试试这个：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;journalctl -u gdm.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（注意：这是个查看 X server 产生的日志的好办法。）那根据特定的进程号？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;journalctl _PID=890
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;您甚至可以请求只看某个可执行文件产生的消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;journalctl /usr/bin/pulseaudio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若您想将输出的消息限制在某个优先级，可以使用&lt;code&gt;-p&lt;/code&gt;选项。该选项参数为 0 的话只会显示紧急消息
（也就是说，是时候向&lt;strong&gt;$DEITY&lt;/strong&gt;祈求保佑了）（LCTT 译注： $DEITY 是一个计算机方面的幽默，
DEITY 是指广义上的“神”，$前缀表示这是一个变量），为 7 的话会显示所有消息，包括调试消息。
请查看手册 (&lt;code&gt;man journalctl&lt;/code&gt;) 获取更多关于优先级的信息。&lt;/p&gt;

&lt;p&gt;值得指出的是，您也可以将多个选项结合在一起，
若想查看在当前启动中由 GDM 服务输出的优先级数小于等于 3 的消息，请使用下述命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;journalctl -u gdm.service -p 3 -b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，如果您仅仅想打开一个随 journal 持续更新的终端窗口，
就像在没有 Systemd 时使用&lt;code&gt;tail&lt;/code&gt;命令实现的那样，输入&lt;code&gt;journalctl -f&lt;/code&gt;就好了。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;http://alienhjy.github.io/images/linux-101-get-the-most-out-of-systemd/05.jpg&#34;/&gt;&lt;/br&gt;
二进制日志并不流行，但 journal 的确有它的优点，如非常方便的信息查找及过滤。
&lt;/div&gt;

&lt;h5 id=&#34;没有-systemd-的生活:0d6c59cee5b31ce37e9176fed3a35e29&#34;&gt;没有 Systemd 的生活？&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;如果您就是完全不能接受 Systemd，您仍然有一些主流发行版中的选择。
尤其是 Slackware，作为历史最为悠久的发行版，目前还没有做出改变，
但它的主要开发者并没有将其从未来规划中移除。
一些不出名的发行版也在坚持使用 SysVinit 。&lt;/p&gt;

&lt;p&gt;但这又将持续多久呢？Gnome 正越来越依赖于 Systemd，其他的主流桌面环境也会步其后尘。
这也是引起 BSD 社区一阵恐慌的原因：Systemd 与 Linux 内核紧密相连，导致在某种程度上，
桌面环境正变得越来越不可移植。一种折衷的解决方案也许会以 Uselessd
(&lt;a href=&#34;http://uselessd.darknedgy.net&#34;&gt;http://uselessd.darknedgy.net&lt;/a&gt;) 的形式到来：一种裁剪版的 Systemd，
纯粹专注于启动和监控进程，而不消耗整个基础系统。&lt;/p&gt;

&lt;div align=&#34;center&#34;&gt;
&lt;img src=&#34;http://alienhjy.github.io/images/linux-101-get-the-most-out-of-systemd/06.jpg&#34;/&gt;&lt;/br&gt;
若您不喜欢 Systemd，可以尝试一下 Gentoo 发行版，它将 Systemd 作为初始化工具的一种选择，但并不强制用户使用 Systemd。
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;http://www.linuxvoice.com/linux-101-get-the-most-out-of-systemd/&#34;&gt;http://www.linuxvoice.com/linux-101-get-the-most-out-of-systemd/&lt;/a&gt;
译文原文地址：&lt;a href=&#34;https://linux.cn/article-6888-1.html&#34;&gt;https://linux.cn/article-6888-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：&lt;a href=&#34;http://www.linuxvoice.com/author/mike/&#34;&gt;Mike Saunders&lt;/a&gt;
译者：&lt;a href=&#34;https://github.com/Ricky-Gong&#34;&gt;Ricky-Gong&lt;/a&gt;
校对：&lt;a href=&#34;https://github.com/wxy&#34;&gt;wxy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文由 &lt;a href=&#34;https://github.com/LCTT/TranslateProject&#34;&gt;LCTT&lt;/a&gt; 原创编译，
&lt;a href=&#34;https://linux.cn/article-6888-1.html&#34;&gt;Linux中国&lt;/a&gt;荣誉推出&lt;/p&gt;

&lt;p&gt;&lt;em&gt;转载者再注：linuxcn的译文原文有非常漂亮的格式，建议阅读linuxcn的译文原文。&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang发送http请求</title>
      <link>http://alienhjy.github.io/2016/2016-01-12_golang-http-request/</link>
      <pubDate>Tue, 12 Jan 2016 18:05:00 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2016/2016-01-12_golang-http-request/</guid>
      <description>

&lt;p&gt;本篇记录一下golang中发送一个http请求的基本方法。&lt;br /&gt;
在本例中，我将尝试向某个URL发送GET请求，并获取其返回的body。&lt;/p&gt;

&lt;h5 id=&#34;b-开门见山的示例代码-b:0b167b783dc027812b7e1e0a9c6b55e6&#34;&gt;&lt;b&gt;开门见山的示例代码&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
	&amp;quot;os&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
)

func GetHttpBody(str_api string) ([]byte) {
	const (
		Http_username = &amp;quot;apiuser&amp;quot;
		Http_passwd = &amp;quot;apipasswd&amp;quot;
	)

	client := &amp;amp;http.Client{}
	req, err_req := http.NewRequest(&amp;quot;GET&amp;quot;, str_api, nil)
	if err_req != nil {
		fmt.Println(&amp;quot;Can&#39;t add http request.&amp;quot;, err_req)
		os.Exit(1)
	}
	req.Header.Add(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;)
	req.SetBasicAuth(Http_username, Http_passwd)

	resp, err_resp := client.Do(req)
	if err_req != nil {
		fmt.Println(&amp;quot;Can&#39;t get http response.&amp;quot;, err_resp)
		os.Exit(1)
	}
	resp_body, _ := ioutil.ReadAll(resp.Body)
	defer resp.Body.Close()
	return resp_body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;b-为了防止自己不懂-尝试解释一下-b:0b167b783dc027812b7e1e0a9c6b55e6&#34;&gt;&lt;b&gt;为了防止自己不懂，尝试解释一下&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;该实例是将go作为http客户端来用，而不是作为server。&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client := &amp;amp;http.Client{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先需要创建一个http client。其实我也不知道为什么是这么创建的。创建http客户端的时候，
还可以控制它的重定向策略等等行为以及其它客户端设置。由于我自己对http协议基本不怎么了解，
所以就不去深究它还能加哪些控制方法了。&lt;br /&gt;
接着便是新建一个&lt;code&gt;http.Request&lt;/code&gt;。其中&lt;code&gt;http.Request.Header.Add&lt;/code&gt;给这个请求添加一条
http头。&lt;code&gt;http.Request.SetBasicAuth&lt;/code&gt;方法用来做基于http协议的、明文密码的基本身份认证。
&lt;code&gt;http.Request&lt;/code&gt;的第一个参数为http请求的方法，第二个参数为请求的URL，如果是&lt;code&gt;POST&lt;/code&gt;等
方法，则可以在第三个参数加上要POST的内容。第三个参数的类型为&lt;code&gt;io.Reader&lt;/code&gt;。
&lt;code&gt;client.DO&lt;/code&gt;将上面创建好的请求发送出去，并返回一个&lt;code&gt;http.Response&lt;/code&gt;，于是我们就可以通过
&lt;code&gt;http.Response.Body&lt;/code&gt;获取到服务器返回的http body。&lt;br /&gt;
&lt;code&gt;http.Response.Body&lt;/code&gt;作为一个&lt;code&gt;io.Reader&lt;/code&gt;，记得在读取完成后&lt;code&gt;Close&lt;/code&gt;掉。&lt;/p&gt;

&lt;p&gt;皆大欢喜皆大欢喜。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debian 创始人 Ian Murdock 先生去世，享年 42 岁！</title>
      <link>http://alienhjy.github.io/2015/2015-12-31_debian-founder-and-docker-employee-ian-murdock-has-died-at-42/</link>
      <pubDate>Thu, 31 Dec 2015 13:14:38 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/2015-12-31_debian-founder-and-docker-employee-ian-murdock-has-died-at-42/</guid>
      <description>&lt;p&gt;Docker 公司&lt;a href=&#34;http://blog.docker.com/2015/12/ian-murdock/&#34;&gt;宣布&lt;/a&gt;，著名的 Debian 创始人 Ian Murdock 已经去世，享年 42 岁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://alienhjy.github.io/images/debian-founder-and-docker-employee-ian-murdock-has-died-at-42.jpg&#34; alt=&#34;ian-murdock&#34; title=&#34;Ian Murdock&#34; /&gt;&lt;/p&gt;

&lt;p&gt;他同时也是 Docker 公司员工、之前还担任过 Linux 基金会的 CTO、 Sun 微系统的印第安纳项目的首席架构师和 SalesForce 员工。
这件事情为他的家人、Debian 社区、Docker 社区以及开源世界带来了巨大悲痛。&lt;/p&gt;

&lt;p&gt;在公布该消息的&lt;a href=&#34;http://blog.docker.com/2015/12/ian-murdock/&#34;&gt;文章&lt;/a&gt;中，并没有说明他的死因。Docker 公司拒绝对此评论。旧金山警局也没有及时提供导致  Ian Murdock  死亡的原因。&lt;/p&gt;

&lt;p&gt;当地时间本周一，他的 Twitter 账户贴了一些推文（&lt;a href=&#34;https://img.sauf.ca/pictures/2015-12-29/c12fc3b2278596da4a26edd4a41f3373.pdf&#34;&gt;PDF 归档&lt;/a&gt;），
表明其与警察发生了一些冲突，夜间的一则&lt;a href=&#34;http://webcache.googleusercontent.com/search?q=cache:umvcoAjl8SIJ:https://twitter.com/imurdock/status/681598929205526528+&amp;amp;cd=1&amp;amp;hl=en&amp;amp;ct=clnk&amp;amp;gl=us&#34;&gt;推文&lt;/a&gt;则
说&lt;a href=&#34;https://linux.cn/article-6818-1.html&#34;&gt;他要自杀&lt;/a&gt;。有人猜测其 Twitter 账户被入侵，
之后，该 &lt;a href=&#34;https://twitter.com/imurdock&#34;&gt;Twitter 账户&lt;/a&gt;被删除了。&lt;/p&gt;

&lt;p&gt;周一晚上， Ian Murdock  去世，目前还不得而知具体事件经过。&lt;/p&gt;

&lt;p&gt;“Ian 率先建立了真正的开源项目和开源社区，拥抱开放设计和开放贡献；事实上开源运动的指导性文件 Open Source Definition（开放源码定义）的形成最初就是来自 Debian 的立场声明”，Docker 的 CEO，Ben Golub 在博文中写到，“这是一份来自 Ian 为开源所贡献的公约，而当前 Debian 社区已经有超过 1000 人参与到其开发之中。”&lt;/p&gt;

&lt;p&gt;Murdock 于 1993年8月&lt;a href=&#34;ianmurdock.com/post/how-i-came-to-find-linux/&#34;&gt;创建了 Debian&lt;/a&gt;，他即是“Debian”这个名字中的“ian”。
在&lt;a href=&#34;http://ianmurdock.com/&#34;&gt;他的个人博客&lt;/a&gt;中，他谈到了该项目的成果，“任何人都可以贡献到它所集成的软件库之中，Debian 可以说是行业内的第一个应用商店（虽然原始）”。&lt;/p&gt;

&lt;p&gt;在过去几年，Docker 成为了&lt;a href=&#34;http://venturebeat.com/2015/04/14/docker-raises-95m-led-by-insight-venture-partners/&#34;&gt;最流行的 Linux 容器&lt;/a&gt;，这与他加入这个初创公司密不可分，
而且他在 Linux 世界里受到广泛赞誉。在周一的 Twitter 上，很多 Debian 用户对他表示了同情和支持。
Debian 社区也发布了&lt;a href=&#34;https://bits.debian.org/2015/12/mourning-ian-murdock.html&#34;&gt;悼念文章&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Debian 及广大的 Linux 社区的人们，可以发送你的哀悼信到 &lt;a href=&#34;mailto:in-memoriam-ian@debian.org&#34;&gt;in-memoriam-ian@debian.org&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考来源：&lt;a href=&#34;http://venturebeat.com/2015/12/30/debian-founder-and-docker-employee-ian-murdock-has-died-at-42/&#34;&gt;venturebeat&lt;/a&gt;
 、&lt;a href=&#34;https://bits.debian.org/2015/12/mourning-ian-murdock.html&#34;&gt;debian&lt;/a&gt;
 、&lt;a href=&#34;https://blog.docker.com/2015/12/ian-murdock/&#34;&gt;docker&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;本文转载自：&lt;a href=&#34;https://linux.cn/article-6828-1.html&#34;&gt;https://linux.cn/article-6828-1.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在RHEL6.2上安装docker的准备工作</title>
      <link>http://alienhjy.github.io/2015/2015-11-06_prepare-for-install-docker-in-rhel_6.2/</link>
      <pubDate>Fri, 06 Nov 2015 19:01:12 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/2015-11-06_prepare-for-install-docker-in-rhel_6.2/</guid>
      <description>

&lt;p&gt;最近在尝试 docker，据说很高端大气上档次，于是就在空闲的时候开始鼓捣整。&lt;br /&gt;
壮哉我大 Arch，内核版本都已经是 4.x 了（截至写本文），完全满足 docker 对内核版本的要求
（推荐 3.16，最低 3.10，据说红帽的 2.6.32-358 以上由于被打了补丁，也能支持 docker）。&lt;/p&gt;

&lt;p&gt;然而事情总不会一帆风顺，比如某些线上环境，可能还在用很古老的发行版。&lt;br /&gt;
现在，我就很奇葩地想要在 RHEL 6.2 上安装 docker。然而 RHEL 6.2 默认使用的内核是
2.6.32-220，并不满足 docker 的要求，于是就需要稍微升级一下内核。
俗话说，步子跨得大了，容易扯到蛋。所以我们选择版本号变化不那么大的 RHEL 6.6 版本自带
的 2.6.32-504 内核。&lt;/p&gt;

&lt;h4 id=&#34;更新内核版本:09a2ede7ed47bf2cfa6c86dd8e573b45&#34;&gt;更新内核版本&lt;/h4&gt;

&lt;p&gt;首先系统的更新内核版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -ivh --force http://yum.pplive.com/rhel_6.6_repo/Packages/kernel-2.6.32-504.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/kernel-firmware-2.6.32-504.el6.noarch.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/bfa-firmware-3.2.23.0-2.el6.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于部分设备，可能会出现依赖不满足。比如我遇到&lt;code&gt;bfa-firmware&lt;/code&gt;包的依赖出现问题，这时，卸载掉旧版本的，
再尝试安装内核，即可解决。可以这样卸载（我不说你也懂）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum remove bfa-firmware
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;更新device-mapper包:09a2ede7ed47bf2cfa6c86dd8e573b45&#34;&gt;更新device-mapper包&lt;/h4&gt;

&lt;p&gt;更新内核后，如果你直接安装运行 docker，会发现启动不了 docker 的服务。不管你有没有这个问题，
反正我是遇到了。这时检查是哪个组件不符合要求，比如我的环境下，是 device-mapper 包版本太低，
更新一下即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rpm -ivh --force http://yum.pplive.com/rhel_6.6_repo/Packages/device-mapper-libs-1.02.90-2.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/device-mapper-1.02.90-2.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/util-linux-ng-2.17.2-12.18.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/libblkid-2.17.2-12.18.el6.x86_64.rpm \
	http://yum.pplive.com/rhel_6.6_repo/Packages/libuuid-2.17.2-12.18.el6.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;安装docker:09a2ede7ed47bf2cfa6c86dd8e573b45&#34;&gt;安装docker&lt;/h4&gt;

&lt;p&gt;话说，标题我不是说了吗，这是准备工作。。。&lt;br /&gt;
接下来，就可以像 RHEL/CentOS 6.5 以上的系统一样，添加&lt;code&gt;epel&lt;/code&gt;源，然后直接安装&lt;code&gt;docker-io&lt;/code&gt;包了。&lt;br /&gt;
神马？怎么添加&lt;code&gt;epel&lt;/code&gt;？怎么安装&lt;code&gt;docker-io&lt;/code&gt;？bing/Google 一下一大堆，这都不会的话还是先回去
补基础吧，别急着用 docker 了。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>内核开发者Sarah Sharp宣布退出</title>
      <link>http://alienhjy.github.io/2015/2015-10-09_the-kernel-developer-sarah-sharp-quit/</link>
      <pubDate>Fri, 09 Oct 2015 20:54:37 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/2015-10-09_the-kernel-developer-sarah-sharp-quit/</guid>
      <description>&lt;p&gt;曾经&lt;a href=&#34;http://www.solidot.org/story?sid=35607&#34;&gt;公开呼吁&lt;/a&gt;Linus Torvalds文明用语的内核开发者
Sarah Sharp&lt;a href=&#34;http://sarah.thesharps.us/2015/10/05/closing-a-door/&#34;&gt;宣布退出（Closing a door）&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Sarah Sharp说，过去一年多时间她已经逐步终止了手中的各项社区工作，转交了USB 3.0主控制器驱动的维护工作，
不再担任开源会议的内核协调员，Linux内核技术咨询委员会的任期结束之后不再寻求再次当选。&lt;br /&gt;
她不再递交任何补丁和bug报告，不再向内核邮件列表写任何的建议。
她声称，Linux内核社区的互动是一种“潜在有毒的背景辐射”，她不再是内核社区的成员。&lt;br /&gt;
她之所以选择这么做当然是因为内核社区的性别歧视，语言暴力和不尊重人。&lt;br /&gt;
内核不久前引入了“&lt;a href=&#34;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/CodeOfConflict&#34;&gt;冲突准则（code of conflict）&lt;/a&gt;”，
以遏制语言暴力现象。
Sarah Sharp认为，没有列出应避免的具体行为的冲突准则是没有力量的，
而社区也没有手段去执行它的准则。
&lt;a href=&#34;https://news.ycombinator.com/item?id=10331891&#34;&gt;HN&lt;/a&gt;和&lt;a href=&#34;http://lwn.net/Articles/659221/#Comments&#34;&gt;LWN&lt;/a&gt;
上有很热烈的讨论。&lt;/p&gt;

&lt;p&gt;转载自：&lt;a href=&#34;http://www.solidot.org/story?sid=45696&#34;&gt;solidot.org&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang中对slice切片进行append时的内存拷贝</title>
      <link>http://alienhjy.github.io/2015/2015-09-25_copy-action-while-append-to-slice-in-golang/</link>
      <pubDate>Fri, 25 Sep 2015 11:13:06 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/2015-09-25_copy-action-while-append-to-slice-in-golang/</guid>
      <description>

&lt;p&gt;Golang中有一个神奇的类型：slice。&lt;br /&gt;
之所以说它神奇，是因为它是有容量的，因此对于熟悉C语言的用户而言，
很难在C语言中找到一个跟slice对应的数据结构。&lt;br /&gt;
本文不对slice的众多特性进行说明，只谈论跟其append操作相关的内容。&lt;/p&gt;

&lt;h5 id=&#34;b-slice的长度与容量-b:777257618f2ade0d10f5e17a35432657&#34;&gt;&lt;b&gt;Slice的长度与容量&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;数组切片 slice 本质上还是基于数组实现的，大概可以抽象为：一个指向原生数组的指针；
数组切片中的元素个数；数组切片已分配的存储空间。&lt;br /&gt;
既然是基于数组，数组本身是不可变长度的，而要实现可变长度，就需要对其存储空间
进行管理。那 go 是怎么对 slice 的存储空间进行管理的呢？&lt;br /&gt;
这时就需要注意到 slice 的中文名称了，数组切片。也就是说，go 本质上将数组弄成一个个
切片，当目前所包含的切片容量不足以容纳所需的元素的时候，就开辟一块新的切片。&lt;br /&gt;
因此，除了长度（length，用&lt;code&gt;len()&lt;/code&gt;函数获取）之外，slice 还包含了另一个属性：容量
（capacity，用&lt;code&gt;cap()&lt;/code&gt;函数获取）。Slice 的长度表示该 slice 中已经存放了多少个元素，
而容量则表示该 slice 已经分配了足以存放多少元素的空间。&lt;br /&gt;
我们可以用一下方法创建一个长度为 4、可容量为 8、用于存放 int 类型元素的 slice：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var sliceA []int = make([]int, 4, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们不指定 make() 的第三个参数 cap 时，切片容量默认等于初始长度，如以下方法可
创建一个长度和容量都为 8 的 slice：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var sliceB []int = make([]int, 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;b-使用-append-方法添加元素-b:777257618f2ade0d10f5e17a35432657&#34;&gt;&lt;b&gt;使用 append() 方法添加元素&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;前面说过 slice 是可变长度的，我们可以利用 append() 函数来为 slice 增加元素。&lt;br /&gt;
&lt;em&gt;前面也说过，本文只讨论 append() 方法，不讨论取子切片、copy() 等其它操作。&lt;/em&gt;&lt;br /&gt;
那么，作为以数组为基础的数据结构，它是怎么做到动态扩展长度的呢？其实就是通过创建
并合并新的切片。&lt;br /&gt;
为了方便讨论，我们姑且把初始化时数组切片的容量称为它的单位容量。&lt;b&gt;请注意这一说法是
无论在 Google 官方文档还是国内翻译文档都未见使用，仅是为了方便讨论而创造的。&lt;/b&gt;&lt;br /&gt;
当进行 append() 操作时，若当前容量足以容纳所有元素，则 append() 会直接把需要添加的
元素直接拷贝到当前已分配的空间内，已有的数据还都在原处，皆大欢喜。而且因为空间是预先
分配好的，不涉及多余的内存申请操作，因此能兼顾动态扩展的灵活性和预分配空间的效率。&lt;br /&gt;
然而，如果当前空间不足的话，又会怎么样呢？&lt;br /&gt;
如果遇到这种情况，append() 会尝试先给这个 slice 分配一个大小为一个单位容量的数组，
如果还不够，继续分配。&lt;/p&gt;

&lt;p&gt;这个时候&lt;b&gt;坑来了，坑来了，坑来了&lt;/b&gt;，重要的事情据说要说三遍。。。&lt;br /&gt;
append() 在为 slice 增加容量的时候，会创建新的 slice，然后把&lt;b&gt;已有的数据拷贝过去，
拷贝过去，拷贝了过去&lt;/b&gt;，因为我掉到过这个坑，所以还是要说三遍。。。&lt;br /&gt;
也就是说，不管你对已存在的数据有没有进行修改，它都要拷贝一遍。如果你认为这个拷贝操作
仅仅是多消耗了一些性能的话，那我们看看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

type StructClass struct {
	id int
}

func (this *StructClass) SetID(newid int) {
	this.id = newid
}

func (this *StructClass) PrintID() {
	go func() {
		for {
			// 每秒输出一次 id 值。
			time.Sleep(time.Second * 1)
			fmt.Println(this.id)
		}
	} ()
}

func main() {
	var (
		i int = 0
		pool []StructClass = make([]StructClass, 0, 4)
	)
	pool = append(pool, StructClass{})
	// 这里将 pool[0] 的 id 设置成 1 了。
	pool[0].SetID(1)
	// 启动一个 goroutine，反复输出 pool[0] 的 id。
	pool[0].PrintID()

	time.Sleep(time.Second * 5)
	for i = 0; i &amp;lt;=5; i = i + 1 {
		pool = append(pool, StructClass{})
	}
	// 请注意此时 pool[0] 的 id 被设置成了 2。
	pool[0].SetID(2)
	time.Sleep(time.Second * 5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先来分析一下程序应该怎么运行。&lt;br /&gt;
首先创建了一个容量为 4，长度为 0 的 slice，该 slice 的每个元素都是一个封装了
一个 goroutine 的结构体。至于怎么制造这么一个结构体，
请参考&lt;a href=&#34;http://alienhjy.github.io/2015/2015-09-20_using-class-like-cpp-in-golang/&#34;&gt;《在golang中使用C++风格的类》&lt;/a&gt;一文。
这时，我们为 pool 添加了一个元素，并为这个元素的成员&lt;code&gt;id&lt;/code&gt;赋予初值，然后让它下属
的 PrintID 方法每隔一秒打印一次它的&lt;code&gt;id&lt;/code&gt;值。&lt;br /&gt;
紧接着，我们为 pool 添加了六个元素，不过暂时不对它们进行操作。添加这六个元素的目的仅仅
是为了迫使 append() 方法为 pool 添加一块区域。&lt;br /&gt;
大约五秒钟后，我们将 pool[0] 的&lt;code&gt;id&lt;/code&gt;设置为2，并等待其输出五秒后退出。&lt;/p&gt;

&lt;p&gt;按道理来说，&lt;code&gt;pool[0].SetID(2)&lt;/code&gt;之后，程序应该是反复输出数字2，然而运行的结果是，程序
全程只输出数字1。&lt;br /&gt;
&lt;b&gt;原因是&lt;/b&gt;，当 slice 元素个数超过四个时，append() 会分配一块大小为 8 的空间，
然后把所有元素拷贝进去。虽然 slice 本身是一个指向数组的指针，但它包含的元素都是
实实在在的数据。在这个例子中，拷贝数据时，append() 实实在在地把 pool[0] 的 id 以及各函数的
定义都拷贝过去了，但正在运行的 goroutine 并不属于数据，因此本例中的那个正在运行
的 goroutine 还傻傻地去原来的地方读取 id 值（注意，此处读取 id 用的是指向结构体的指针，
该指针还是指向原来的数据）。&lt;/p&gt;

&lt;h5 id=&#34;b-代码修正-b:777257618f2ade0d10f5e17a35432657&#34;&gt;&lt;b&gt;代码修正&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;既然我们知道了引发问题的原因，那事情也就好解决了。&lt;br /&gt;
我们只需在创建 slice 的时候，往里面存放指向 StructClass 的指针，而不是直接
存放 StructClass 结构体就行了。
上述代码其它部分保持不变，将&lt;code&gt;main&lt;/code&gt;函数修改为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	var (
		i int = 0
		pool []*StructClass = make([]*StructClass, 0, 4)	// 改了这行
	)
	pool = append(pool, new(StructClass))	// 还有这行
	// 这里将 pool[0] 的 id 设置成 1 了。
	pool[0].SetID(1)
	// 启动一个 goroutine，反复输出 pool[0] 的 id。
	pool[0].PrintID()

	time.Sleep(time.Second * 5)
	for i = 0; i &amp;lt;=5; i = i + 1 {
		pool = append(pool, new(StructClass))	// 还有这行
	}
	// 请注意此时 pool[0] 的 id 被设置成了 2。
	pool[0].SetID(2)
	time.Sleep(time.Second * 5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我懒，所以上述代码的运行结果我都懒得贴了。感兴趣的可以自己测试一下，修改后
的代码正如我们期望的那样，先输出1，五秒后输出2。&lt;br /&gt;
若 slice 存放的是指针，那在 append() 进行拷贝操作的时候，只是将指针的指向的地址拷贝过去，
&lt;code&gt;pool[0].SetID(2)&lt;/code&gt;语句修改的 id 和&lt;code&gt;pool[0].PrintID()&lt;/code&gt;取的 id 引用的地址始终是不变的。&lt;/p&gt;

&lt;h4 id=&#34;所以说-谁说带垃圾回收的语言不用考虑指针t-t:777257618f2ade0d10f5e17a35432657&#34;&gt;所以说，谁说带垃圾回收的语言不用考虑指针T_T&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>在golang中使用C&#43;&#43;风格的类</title>
      <link>http://alienhjy.github.io/2015/2015-09-20_using-class-like-cpp-in-golang/</link>
      <pubDate>Sun, 20 Sep 2015 21:05:59 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/2015-09-20_using-class-like-cpp-in-golang/</guid>
      <description>

&lt;p&gt;对于接触过C++且刚入门golang的用户而言，有一点可能会让他们抓狂，
就是golang这货居然只有结构体（struct），没有类（class）！！！&lt;br /&gt;
其实不用担心，我们大可以用struct实现类似于class的功能。。。&lt;/p&gt;

&lt;h5 id=&#34;b-目的-b:5b88b4afc8a2f6c27657f65b3600d208&#34;&gt;&lt;b&gt;目的：&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;使struct不仅仅能存储成员变量，还能拥有其成员函数。并且控制外部函数对私有成员变量的访问。
当然本文仅仅是为了实现上述目的而已，并不关心什么多态、继承等等一大堆乱七八糟的特性（好吧，其实是本渣并不懂那些高级特性）。&lt;/p&gt;

&lt;h5 id=&#34;b-c-中类的使用-b:5b88b4afc8a2f6c27657f65b3600d208&#34;&gt;&lt;b&gt;C++中类的使用：&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;我们先来看一段C++中是怎么样使用类的。&lt;br /&gt;
首先我们来创建一个头文件&lt;code&gt;classa.h&lt;/code&gt;，如你所见，类名叫classa：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class classa {
private:
	int id;

public:
	void SetID(int);
	int GetID();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们再创建一个源文件&lt;code&gt;classa.cpp&lt;/code&gt;，用来实现classa的&lt;code&gt;SetID&lt;/code&gt;和&lt;code&gt;GetID&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;classa.h&amp;quot;

void classa::SetID(int newid) {
	this-&amp;gt;id = newid;
}

int classa::GetID() {
	return this-&amp;gt;id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，建立&lt;code&gt;main.cpp&lt;/code&gt;用来初始化一个类的实例，并尝试调用类中的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;classa.h&amp;quot;

using namespace std;

int main(int argc, char* argv[]) {
	classa ca;
	ca.SetID(4);
	cout &amp;lt;&amp;lt; ca.GetID() &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;g++ -o main main.cpp classa.cpp&lt;/code&gt;编译上述文件，并运行&lt;code&gt;./main&lt;/code&gt;，
如果输出了一个数字4，那这个classa类就应当是以正确的姿势被调用了。&lt;/p&gt;

&lt;h5 id=&#34;b-golang中为struct添加成员函数-b:5b88b4afc8a2f6c27657f65b3600d208&#34;&gt;&lt;b&gt;golang中为struct添加成员函数&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;不多废话了，作为对比，我们把上述C++代码翻译成golang代码。&lt;br /&gt;
假定我们目前的工作目录为&lt;code&gt;GOPATH&lt;/code&gt;，我们在当前路径的子目录下创建一个
名叫&lt;code&gt;packagea&lt;/code&gt;的包，包文件在&lt;code&gt;GOPATH&lt;/code&gt;下的路径为&lt;code&gt;src/packagea/packagea.go&lt;/code&gt;，
内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package packagea

type StructClass struct {
	id int 
}

func (this *StructClass) SetID(newid int) {
	this.id = newid
}

func (this *StructClass) GetID() int {
	return this.id
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，编写&lt;code&gt;main&lt;/code&gt;包以使用&lt;code&gt;packagea&lt;/code&gt;包，&lt;code&gt;main&lt;/code&gt;包的位置应该在哪就不用多说了吧。&lt;br /&gt;
&lt;code&gt;main&lt;/code&gt;包的内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;packagea&amp;quot;
)

func main() {
	var (
		sc packagea.StructClass = packagea.StructClass{}
	)
	sc.SetID(4)
	fmt.Println(sc.GetID())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;为了便于新手（其实是我自己）理解，我尽量不会使用&lt;code&gt;:=&lt;/code&gt;来声明一个变量，
而是使用臭长臭长的显式声明，以容易对变量的类型一目了然。&lt;/em&gt;&lt;br /&gt;
如果你希望以指向结构体的指针的形式来声明&lt;code&gt;sc&lt;/code&gt;这个结构体，只需把
&lt;code&gt;sc packagea.StructClass = packagea.StructClass{}&lt;/code&gt;替换为
&lt;code&gt;sc *packagea.StructClass = &amp;amp;packagea.StructClass{}&lt;/code&gt;即可。&lt;/p&gt;

&lt;h5 id=&#34;b-总结-b:5b88b4afc8a2f6c27657f65b3600d208&#34;&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;之前网上找的教程基本上都是把结构体和跟它们关联的函数放在&lt;code&gt;main.go&lt;/code&gt;（与方法调用者
在同一个包里）。
如果我们希望把它们模块化，当然需要把一个模块的东西放到单独的包中。这个时候需要
注意的是，小写字母开头的变量和方法都只能在同一个包中被使用，类似于C++类
中的&lt;code&gt;protect&lt;/code&gt;属性。至于&lt;code&gt;private&lt;/code&gt;属性？你把每个结构体以及它们关联的方法单独放到
一个包不久行了。。。&lt;br /&gt;
本文所说的这种用法其实应该是go里面很常见的用法，只是本人愚笨，搞了好久才搞清楚。
所以在这里记录一下，以便以后哪天又忘了的话可以翻阅。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>苦逼地不会Markdown</title>
      <link>http://alienhjy.github.io/2015/2015-09-17_markdown-test/</link>
      <pubDate>Thu, 17 Sep 2015 09:19:33 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/2015-09-17_markdown-test/</guid>
      <description>

&lt;p&gt;本文的 Markdown 源码可到&lt;a href=&#34;https://raw.githubusercontent.com/alienhjy/hugo-build-repo/master/content/post/markdown-test.md&#34;&gt;https://raw.githubusercontent.com/alienhjy/hugo-build-repo/master/content/post/markdown-test.md&lt;/a&gt;查看。&lt;br /&gt;
不过我知道写得很渣，轻喷。。。&lt;/p&gt;

&lt;p&gt;独立的行中有三个以上的星号，下面应当有一条分割线&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;这是二级标题:ce60f5aebf1bcee072dab7bdb88177a3&#34;&gt;这是二级标题&lt;/h2&gt;

&lt;h4 id=&#34;这是四级标题:ce60f5aebf1bcee072dab7bdb88177a3&#34;&gt;这是四级标题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;这是一个引用,
然而这里并没有换行。。。&lt;br /&gt;
上一句行尾有两个空格，瞧，这里换行了吧～&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;引用支持嵌套。然而嵌套的引用应该跟上一级的引用在不同的块，&lt;br /&gt;
即，嵌套的引用跟其它级别之间应当用空行分隔开。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;无序列表可以用星号&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这是第二个列表项&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可以用加号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然而列表并不起作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可以用减号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然而三种无序列表都没有作用。。。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字加英文句号是有序列表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然而有序列表貌似没什么卵用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是代码段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
echo &amp;quot;hello markdown&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行首有四个空格或者tab，也应当是一个代码段。这种方式的代码段前后应当有空行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于本主题的高亮实在有问题，我从 purehugo 主题取了一个 syntax-highlighter.css 样式表过来，才勉强给代码段周围加上框框，但依旧没有解决语法高亮的问题。。。包括各种列表样式不准确等等，总之问题多多。。。&lt;/p&gt;

&lt;p&gt;单星号 = &lt;em&gt;斜体&lt;/em&gt;&lt;br /&gt;
单下划线 = &lt;em&gt;斜体&lt;/em&gt;&lt;br /&gt;
双星号 = &lt;strong&gt;加粗&lt;/strong&gt;&lt;br /&gt;
双下划线 = &lt;strong&gt;加粗&lt;/strong&gt;&lt;br /&gt;
&lt;b&gt;加粗就是不生效。。。看我来一段HTML格式的加粗&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;这是InLine风格的&lt;a href=&#34;https://github.com/&#34; title=&#34;这是可选标题&#34;&gt;链接&lt;/a&gt;&lt;br /&gt;
这是Reference风格的&lt;a href=&#34;https://github.com/&#34; title=&#34;这是可选标题&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这是InLine风格的图片示例：&lt;img src=&#34;http://alienhjy.github.io/images/logo.jpg&#34; alt=&#34;替代文本&#34; title=&#34;可选标题&#34; /&gt;&lt;br /&gt;
这是Reference风格的图片示例：&lt;img src=&#34;http://alienhjy.github.io/images/logo.jpg&#34; alt=&#34;替代文本&#34; title=&#34;可选标题&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是HTML风格的图片示例：&lt;img src=&#34;http://alienhjy.github.io/images/logo.jpg&#34; alt=&#34;替代文本&#34; title=“可选标题” width=200 /&gt;&lt;/p&gt;

&lt;h4 id=&#34;其它:ce60f5aebf1bcee072dab7bdb88177a3&#34;&gt;其它&lt;/h4&gt;

&lt;h5 id=&#34;自动链接:ce60f5aebf1bcee072dab7bdb88177a3&#34;&gt;自动链接：&lt;/h5&gt;

&lt;p&gt;使用尖括号，可以为邮箱地址或者链接创建自动链接，比如这个：&lt;a href=&#34;https://github.com/&#34;&gt;https://github.com/&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;分隔线:ce60f5aebf1bcee072dab7bdb88177a3&#34;&gt;分隔线&lt;/h5&gt;

&lt;p&gt;在一行中使用三个或三个以上的*、-或_可以添加分隔线，其中可以有空白，但是不能有其他字符。&lt;/p&gt;

&lt;h5 id=&#34;转义字符:ce60f5aebf1bcee072dab7bdb88177a3&#34;&gt;转义字符&lt;/h5&gt;

&lt;p&gt;Markdown中的转义字符为\，可以转义的有：&lt;br /&gt;
    \\ 反斜杠&lt;br /&gt;
    \` 反引号&lt;br /&gt;
    \* 星号&lt;br /&gt;
    \_ 下划线&lt;br /&gt;
    \{\} 大括号&lt;br /&gt;
    \[\] 中括号&lt;br /&gt;
    \(\) 小括号&lt;br /&gt;
    \# 井号&lt;br /&gt;
    \+ 加号&lt;br /&gt;
    \- 减号&lt;br /&gt;
    \. 英文句号&lt;br /&gt;
    \! 感叹号&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>