<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>码农向 on 黄家垚的主页</title>
    <link>http://alienhjy.github.io/categories/%E7%A0%81%E5%86%9C%E5%90%91/</link>
    <description>Recent content in 码农向 on 黄家垚的主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2015 Copyleft Text</copyright>
    <lastBuildDate>Sun, 20 Sep 2015 21:05:59 +0800</lastBuildDate>
    <atom:link href="http://alienhjy.github.io/categories/%E7%A0%81%E5%86%9C%E5%90%91/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在golang中使用C&#43;&#43;风格的类</title>
      <link>http://alienhjy.github.io/2015/09/20/using-class-like-cpp-in-golang/</link>
      <pubDate>Sun, 20 Sep 2015 21:05:59 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/09/20/using-class-like-cpp-in-golang/</guid>
      <description>

&lt;p&gt;对于接触过C++且刚入门golang的用户而言，有一点可能会让他们抓狂，
就是golang这货居然只有结构体（struct），没有类（class）！！！&lt;br /&gt;
其实不用担心，我们大可以用struct实现类似于class的功能。。。&lt;/p&gt;

&lt;h5 id=&#34;b-目的-b:403e7f83b95b7e782b794eb436e4a3ae&#34;&gt;&lt;b&gt;目的：&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;使struct不仅仅能存储成员变量，还能拥有其成员函数。并且控制外部函数对私有成员变量的访问。
当然本文仅仅是为了实现上述目的而已，并不关心什么多态、继承等等一大堆乱七八糟的特性（好吧，其实是本渣并不懂那些高级特性）。&lt;/p&gt;

&lt;h5 id=&#34;b-c-中类的使用-b:403e7f83b95b7e782b794eb436e4a3ae&#34;&gt;&lt;b&gt;C++中类的使用：&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;我们先来看一段C++中是怎么样使用类的。&lt;br /&gt;
首先我们来创建一个头文件&lt;code&gt;classa.h&lt;/code&gt;，如你所见，类名叫classa：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class classa {
private:
	int id;

public:
	void SetID(int);
	int GetID();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们再创建一个源文件&lt;code&gt;classa.cpp&lt;/code&gt;，用来实现classa的&lt;code&gt;SetID&lt;/code&gt;和&lt;code&gt;GetID&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;classa.h&amp;quot;

void classa::SetID(int newid) {
	this-&amp;gt;id = newid;
}

int classa::GetID() {
	return this-&amp;gt;id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，建立&lt;code&gt;main.cpp&lt;/code&gt;用来初始化一个类的实例，并尝试调用类中的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;classa.h&amp;quot;

using namespace std;

int main(int argc, char* argv[]) {
	classa ca;
	ca.SetID(4);
	cout &amp;lt;&amp;lt; ca.GetID() &amp;lt;&amp;lt; endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;g++ -o main main.cpp classa.cpp&lt;/code&gt;编译上述文件，并运行&lt;code&gt;./main&lt;/code&gt;，
如果输出了一个数字4，那这个classa类就应当是以正确的姿势被调用了。&lt;/p&gt;

&lt;h5 id=&#34;b-golang中为struct添加成员函数-b:403e7f83b95b7e782b794eb436e4a3ae&#34;&gt;&lt;b&gt;golang中为struct添加成员函数&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;不多废话了，作为对比，我们把上述C++代码翻译成golang代码。&lt;br /&gt;
假定我们目前的工作目录为&lt;code&gt;GOPATH&lt;/code&gt;，我们在当前路径的子目录下创建一个
名叫&lt;code&gt;packagea&lt;/code&gt;的包，包文件在&lt;code&gt;GOPATH&lt;/code&gt;下的路径为&lt;code&gt;src/packagea/packagea.go&lt;/code&gt;，
内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package packagea

type StructClass struct {
	id int 
}

func (this *StructClass) SetID(newid int) {
	this.id = newid
}

func (this *StructClass) GetID() int {
	return this.id
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，编写&lt;code&gt;main&lt;/code&gt;包以使用&lt;code&gt;packagea&lt;/code&gt;包，&lt;code&gt;main&lt;/code&gt;包的位置应该在哪就不用多说了吧。&lt;br /&gt;
&lt;code&gt;main&lt;/code&gt;包的内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;packagea&amp;quot;
)

func main() {
	var (
		sc packagea.StructClass = packagea.StructClass{}
	)
	sc.SetID(4)
	fmt.Println(sc.GetID())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;为了便于新手（其实是我自己）理解，我尽量不会使用&lt;code&gt;:=&lt;/code&gt;来声明一个变量，
而是使用臭长臭长的显式声明，以容易对变量的类型一目了然。&lt;/em&gt;&lt;br /&gt;
如果你希望以指向结构体的指针的形式来声明&lt;code&gt;sc&lt;/code&gt;这个结构体，只需把
&lt;code&gt;sc packagea.StructClass = packagea.StructClass{}&lt;/code&gt;替换为
&lt;code&gt;sc *packagea.StructClass = &amp;amp;packagea.StructClass{}&lt;/code&gt;即可。&lt;/p&gt;

&lt;h5 id=&#34;b-总结-b:403e7f83b95b7e782b794eb436e4a3ae&#34;&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h5&gt;

&lt;hr /&gt;

&lt;p&gt;之前网上找的教程基本上都是把结构体和跟它们关联的函数放在&lt;code&gt;main.go&lt;/code&gt;（与方法调用者
在同一个包里）。
如果我们希望把它们模块化，当然需要把一个模块的东西放到单独的包中。这个时候需要
注意的是，小写字母开头的变量和方法都只能在同一个包中被使用，类似于C++类
中的&lt;code&gt;protect&lt;/code&gt;属性。至于&lt;code&gt;private&lt;/code&gt;属性？你把每个结构体以及它们关联的方法单独放到
一个包不久行了。。。&lt;br /&gt;
本文所说的这种用法其实应该是go里面很常见的用法，只是本人愚笨，搞了好久才搞清楚。
所以在这里记录一下，以便以后哪天又忘了的话可以翻阅。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>苦逼地不会Markdown</title>
      <link>http://alienhjy.github.io/2015/09/17/markdown-test/</link>
      <pubDate>Thu, 17 Sep 2015 09:19:33 +0800</pubDate>
      
      <guid>http://alienhjy.github.io/2015/09/17/markdown-test/</guid>
      <description>

&lt;p&gt;本文的 Markdown 源码可到&lt;a href=&#34;https://raw.githubusercontent.com/alienhjy/hugo-build-repo/master/content/post/markdown-test.md&#34;&gt;https://raw.githubusercontent.com/alienhjy/hugo-build-repo/master/content/post/markdown-test.md&lt;/a&gt;查看。&lt;br /&gt;
不过我知道写得很渣，轻喷。。。&lt;/p&gt;

&lt;p&gt;独立的行中有三个以上的星号，下面应当有一条分割线&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;这是二级标题:86ac849859807c9737e753d784ef51b4&#34;&gt;这是二级标题&lt;/h2&gt;

&lt;h4 id=&#34;这是四级标题:86ac849859807c9737e753d784ef51b4&#34;&gt;这是四级标题&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;这是一个引用,
然而这里并没有换行。。。&lt;br /&gt;
上一句行尾有两个空格，瞧，这里换行了吧～&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;引用支持嵌套。然而嵌套的引用应该跟上一级的引用在不同的块，&lt;br /&gt;
即，嵌套的引用跟其它级别之间应当用空行分隔开。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;无序列表可以用星号&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这是第二个列表项&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可以用加号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然而列表并不起作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可以用减号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然而三种无序列表都没有作用。。。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字加英文句号是有序列表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然而有序列表貌似没什么卵用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是代码段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
echo &amp;quot;hello markdown&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行首有四个空格或者tab，也应当是一个代码段。这种方式的代码段前后应当有空行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于本主题的高亮实在有问题，我从 purehugo 主题取了一个 syntax-highlighter.css 样式表过来，才勉强给代码段周围加上框框，但依旧没有解决语法高亮的问题。。。包括各种列表样式不准确等等，总之问题多多。。。&lt;/p&gt;

&lt;p&gt;单星号 = &lt;em&gt;斜体&lt;/em&gt;&lt;br /&gt;
单下划线 = &lt;em&gt;斜体&lt;/em&gt;&lt;br /&gt;
双星号 = &lt;strong&gt;加粗&lt;/strong&gt;&lt;br /&gt;
双下划线 = &lt;strong&gt;加粗&lt;/strong&gt;&lt;br /&gt;
&lt;b&gt;加粗就是不生效。。。看我来一段HTML格式的加粗&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;这是InLine风格的&lt;a href=&#34;https://github.com/&#34; title=&#34;这是可选标题&#34;&gt;链接&lt;/a&gt;&lt;br /&gt;
这是Reference风格的&lt;a href=&#34;https://github.com/&#34; title=&#34;这是可选标题&#34;&gt;链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这是InLine风格的图片示例：&lt;img src=&#34;http://alienhjy.github.io/images/logo.jpg&#34; alt=&#34;替代文本&#34; title=&#34;可选标题&#34; /&gt;
&lt;br /&gt;
这是Reference风格的图片示例：&lt;img src=&#34;http://alienhjy.github.io/images/logo.jpg&#34; alt=&#34;替代文本&#34; title=&#34;可选标题&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;这是HTML风格的图片示例：&lt;img src=&#34;http://alienhjy.github.io/images/logo.jpg&#34; alt=&#34;替代文本&#34; title=“可选标题” width=200 /&gt;&lt;/p&gt;

&lt;h4 id=&#34;其它:86ac849859807c9737e753d784ef51b4&#34;&gt;其它&lt;/h4&gt;

&lt;h5 id=&#34;自动链接:86ac849859807c9737e753d784ef51b4&#34;&gt;自动链接：&lt;/h5&gt;

&lt;p&gt;使用尖括号，可以为邮箱地址或者链接创建自动链接，比如这个：&lt;a href=&#34;https://github.com/&#34;&gt;https://github.com/&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;分隔线:86ac849859807c9737e753d784ef51b4&#34;&gt;分隔线&lt;/h5&gt;

&lt;p&gt;在一行中使用三个或三个以上的*、-或_可以添加分隔线，其中可以有空白，但是不能有其他字符。&lt;/p&gt;

&lt;h5 id=&#34;转义字符:86ac849859807c9737e753d784ef51b4&#34;&gt;转义字符&lt;/h5&gt;

&lt;p&gt;Markdown中的转义字符为\，可以转义的有：&lt;br /&gt;
    \\ 反斜杠&lt;br /&gt;
    \` 反引号&lt;br /&gt;
    \* 星号&lt;br /&gt;
    \_ 下划线&lt;br /&gt;
    \{\} 大括号&lt;br /&gt;
    \[\] 中括号&lt;br /&gt;
    \(\) 小括号&lt;br /&gt;
    \# 井号&lt;br /&gt;
    \+ 加号&lt;br /&gt;
    \- 减号&lt;br /&gt;
    \. 英文句号&lt;br /&gt;
    \! 感叹号&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>